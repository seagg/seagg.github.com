<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>心静茹水</title>
    <description>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 26 Jan 2017 10:47:23 +0800</pubDate>
    <lastBuildDate>Thu, 26 Jan 2017 10:47:23 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>RDD</title>
        <description>&lt;p&gt;Repost from:[&lt;a href=&quot;http://homepage.cs.latrobe.edu.au/zhe/ZhenHeSparkRDDAPIExamples.html&quot;&gt;http://homepage.cs.latrobe.edu.au/zhe/ZhenHeSparkRDDAPIExamples.html&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;The RDD API By Example&lt;/span&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
&lt;p class=&quot;p9 ft4&quot;&gt;RDD is short for Resilient Distributed Dataset.
   RDDs
   are the workhorse of the Spark system. As a user, one can consider a
   RDD as a handle for a collection of individual data partitions, which
   are the result of some computation.
&lt;/p&gt;
&lt;p class=&quot;p22 ft4&quot;&gt;However, an RDD is actually more than that. On
   cluster installations, separate data partitions can be on separate
   nodes. Using the RDD as a handle one can access all partitions and
   perform computations and transformations using the contained data.
   Whenever a part of a RDD or an entire RDD is lost, the system is able
   to reconstruct the data of lost partitions by using lineage
   information. Lineage refers to the sequence of transformations used to
   produce the current RDD. As a result, Spark is able to recover
   automatically from most failures.
&lt;/p&gt;
&lt;p class=&quot;p23 ft8&quot;&gt;All RDDs available in Spark derive either
   directly
   or indirectly from the class RDD. This class comes with a large set of
   methods that perform operations on the data within the associated
   partitions. The class RDD is abstract. Whenever, one uses a RDD, one is
   actually using a concertized implementation of RDD. These
   implementations have to overwrite some core functions to make the RDD
   behave as expected.
&lt;/p&gt;
&lt;p class=&quot;p24 ft4&quot;&gt;
   One reason why Spark has lately become a very
   popular system for processing big data is that it does not impose
   restrictions regarding what data can be stored within RDD partitions.
   The RDD API already contains many useful operations. But, because the
   creators of Spark had to keep the core API of RDDs common enough to
   handle arbitrary 
   &lt;nobr&gt;data-types,&lt;/nobr&gt;
   many convenience functions
   are missing.
&lt;/p&gt;
&lt;p class=&quot;p10 ft4&quot;&gt;
   The basic RDD API considers each data item as
   a single value. However, users often want to work with 
   &lt;nobr&gt;key-value&lt;/nobr&gt;
   pairs. Therefore Spark extended the interface of RDD to provide
   additional functions (PairRDDFunctions), which explicitly work on 
   &lt;nobr&gt;key-value&lt;/nobr&gt;
   pairs. Currently, there are four extensions to the RDD API available in
   spark. They are as follows:
&lt;/p&gt;
&lt;p class=&quot;p25 ft4&quot;&gt;DoubleRDDFunctions &lt;br&gt;
&lt;/p&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   This extension contains many
   useful methods for aggregating numeric values. They become available if
   the data items of an RDD are implicitly convertible to the Scala 
   &lt;nobr&gt;data-type&lt;/nobr&gt;
   double.
&lt;/div&gt;
&lt;p class=&quot;p26 ft4&quot;&gt;PairRDDFunctions &lt;br&gt;
&lt;/p&gt;
&lt;p style=&quot;margin-left: 40px;&quot; class=&quot;p26 ft4&quot;&gt;Methods defined in
   this interface
   extension become available when the data items have a two component
   tuple structure. Spark will interpret the first tuple item (i.e.
   tuplename. 1) as the key and the second item (i.e. tuplename. 2) as the
   associated value.
&lt;/p&gt;
&lt;p class=&quot;p27 ft4&quot;&gt;OrderedRDDFunctions &lt;br&gt;
&lt;/p&gt;
&lt;p style=&quot;margin-left: 40px;&quot; class=&quot;p27 ft4&quot;&gt;Methods defined in
   this interface
   extension become available if the data items are two-component tuples
   where the key is implicitly sortable.
&lt;/p&gt;
&lt;p class=&quot;p28 ft9&quot;&gt;SequenceFileRDDFunctions &lt;br&gt;
&lt;/p&gt;
&lt;p style=&quot;margin-left: 40px;&quot; class=&quot;p29 ft4&quot;&gt;
   This extension
   contains
   several methods that allow users to create Hadoop sequence- les from
   RDDs. The data items must be two compo- nent 
   &lt;nobr&gt;key-value&lt;/nobr&gt;
   tuples as required by the PairRDDFunctions. However, there are
   additional requirements considering the convertibility of the tuple
   components to Writable types.
&lt;/p&gt;
&lt;p class=&quot;p30 ft4&quot;&gt;
   Since Spark will make methods with extended
   functionality automatically available to users when the data items
   fulfill the above described requirements, we decided to list all
   possible
   available functions in strictly alphabetical order. We will append
   either of the followingto the 
   &lt;nobr&gt;function-name&lt;/nobr&gt;
   to indicate
   it belongs to an extension that requires the data items to conform to a
   certain format or type.
&lt;/p&gt;
&lt;p class=&quot;p30 ft4&quot;&gt; &lt;span class=&quot;ft10&quot;&gt;[Double] &lt;/span&gt;- Double
   RDD Functions&lt;br&gt;
&lt;/p&gt;
&lt;p class=&quot;p30 ft4&quot;&gt; &lt;span class=&quot;ft10&quot;&gt;[Ordered]&lt;/span&gt; -
   OrderedRDDFunctions&lt;br&gt;
&lt;/p&gt;
&lt;p class=&quot;p30 ft4&quot;&gt; &lt;span class=&quot;ft10&quot;&gt;[Pair] - PairRDDFunctions&lt;br&gt;
   &lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;p30 ft4&quot;&gt;&lt;span class=&quot;ft10&quot;&gt;&lt;/span&gt;&lt;span class=&quot;ft10&quot;&gt;[SeqFile]&lt;/span&gt;
   - SequenceFileRDDFunctions
&lt;/p&gt;
&lt;p class=&quot;p30 ft4&quot;&gt;&lt;br&gt;
&lt;/p&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;a name=&quot;aggregate&quot;&gt;&lt;/a&gt;&lt;br&gt;
aggregate&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
The &lt;span style=&quot;font-weight: bold;&quot;&gt;aggregate&lt;/span&gt; function allows the user to apply &lt;span style=&quot;font-weight: bold;&quot;&gt;two&lt;/span&gt;
different reduce functions to the RDD. The first reduce function is
applied within each partition to reduce the data within each partition
into a single result. The second reduce function is used to combine the
different reduced results of all partitions together to arrive at one
final result. The ability to have two separate reduce functions for
intra partition versus across partition reducing adds a lot of
flexibility. For example the first reduce function can be the max
function and the second one can be the sum function. The user also
specifies an initial value. Here are some important facts.
&lt;ul&gt;
   &lt;li&gt;The initial value is applied at both levels of reduce. So both at the intra partition reduction and across partition reduction.&lt;br&gt;&lt;/li&gt;
   &lt;li&gt;Both reduce functions have to be commutative and
      associative.
   &lt;/li&gt;
   &lt;li&gt;Do not assume any execution order for either partition
      computations or combining partitions.
   &lt;/li&gt;
   &lt;li&gt;Why would one want to use two input data types? Let us
      assume we do an archaeological site survey using a metal detector.
      While walking through the site we take GPS coordinates of important
      findings based on the output of the metal detector. Later, we intend to
      draw an image of a map that highlights these locations using the &lt;span style=&quot;font-weight: bold;&quot;&gt;aggregate &lt;/span&gt;function. In this case
      the &lt;span style=&quot;font-weight: bold;&quot;&gt;zeroValue&lt;/span&gt;
      could be an area map with no highlights. The possibly huge set of input
      data is stored as GPS coordinates across many partitions. &lt;span style=&quot;font-weight: bold;&quot;&gt;seqOp (first reducer)&lt;/span&gt; could convert the GPS
      coordinates to map coordinates and put a marker on the map at the
      respective position. &lt;span style=&quot;font-weight: bold;&quot;&gt;combOp (second reducer) &lt;/span&gt;will
      receive these highlights as partial maps and combine them into a single
      final output map.
   &lt;/li&gt;
&lt;/ul&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def aggregate&lt;a href=&quot;zeroValue:%20U&quot;&gt;U:
   ClassTag&lt;/a&gt;(seqOp: (U, T) =&amp;gt; U, combOp: (U, U) =&amp;gt; U):
   U&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;p30 ft4&quot;&gt;Examples 1&lt;/p&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 559px; height: 340px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               z = sc.parallelize(List(1,2,3,4,5,6), 2)&lt;br&gt;
               &lt;br&gt;
               // lets first print out the contents of the RDD with partition labels&lt;br&gt;
               def myfunc(index: Int, iter: Iterator[(Int)]) : Iterator[String] = {&lt;br&gt;
               &amp;nbsp; iter.toList.map(x =&amp;gt; &amp;ldquo;[partID:&amp;rdquo; +&amp;nbsp; index + &amp;ldquo;, val: &amp;rdquo; + x + &amp;ldquo;]&amp;rdquo;).iterator&lt;br&gt;
               }&lt;br&gt;
               &lt;br&gt;
               z.mapPartitionsWithIndex(myfunc).collect&lt;br&gt;
               res28: Array[String] = Array([partID:0, val: 1], [partID:0, val: 2],
               [partID:0, val: 3], [partID:1, val: 4], [partID:1, val: 5], [partID:1,
               val: 6])&lt;br&gt;
               &lt;br&gt;
               z.aggregate(0)(math.max(&lt;em&gt;, _), _ + _)&lt;br&gt;
               res40: Int = 9&lt;br&gt;
               &lt;br&gt;
               // This example returns 16 since the initial value is 5&lt;br&gt;
               // reduce of partition 0 will be max(5, 1, 2, 3) = 5&lt;br&gt;
               // reduce of partition 1 will be max(5, 4, 5, 6) = 6&lt;br&gt;
               // final reduce across partitions will be 5 + 5 + 6 = 16&lt;br&gt;
               // note the final reduce include the initial value&lt;br&gt;
               z.aggregate(5)(math.max(&lt;/em&gt;, &lt;em&gt;), _ + _)&lt;br&gt;
               res29: Int = 16&lt;br&gt;
               &lt;br&gt;
               &lt;br&gt;
               val z = sc.parallelize(List(&amp;ldquo;a&amp;rdquo;,&amp;ldquo;b&amp;rdquo;,&amp;ldquo;c&amp;rdquo;,&amp;ldquo;d&amp;rdquo;,&amp;ldquo;e&amp;rdquo;,&amp;ldquo;f&amp;rdquo;),2)&lt;br&gt;
               &lt;br&gt;
               //lets first print out the contents of the RDD with partition labels&lt;br&gt;
               def myfunc(index: Int, iter: Iterator[(String)]) : Iterator[String] = {&lt;br&gt;
               &amp;nbsp; iter.toList.map(x =&amp;gt; &amp;ldquo;[partID:&amp;rdquo; +&amp;nbsp; index + &amp;ldquo;, val: &amp;rdquo; + x + &amp;ldquo;]&amp;rdquo;).iterator&lt;br&gt;
               }&lt;br&gt;
               &lt;br&gt;
               z.mapPartitionsWithIndex(myfunc).collect&lt;br&gt;
               res31: Array[String] = Array([partID:0, val: a], [partID:0, val: b],
               [partID:0, val: c], [partID:1, val: d], [partID:1, val: e], [partID:1,
               val: f])&lt;br&gt;
               &lt;br&gt;
               z.aggregate(&amp;ldquo;&amp;rdquo;)(&lt;/em&gt; + &lt;em&gt;, _+&lt;/em&gt;)&lt;br&gt;
               res115: String = abcdef&lt;br&gt;
               &lt;br&gt;
               // See here how the initial value &amp;ldquo;x&amp;rdquo; is applied three times.&lt;br&gt;
               //&amp;nbsp; - once for each partition&lt;br&gt;
               //&amp;nbsp; - once when combining all the partitions in the second reduce function.&lt;br&gt;
               z.aggregate(&amp;ldquo;x&amp;rdquo;)(_ + &lt;em&gt;, _+&lt;/em&gt;)&lt;br&gt;
               res116: String = xxdefxabc&lt;br&gt;
               &lt;br&gt;
               // Below are some more advanced examples. Some are quite tricky to work out.&lt;br&gt;
               &lt;br&gt;
               val z = sc.parallelize(List(&amp;ldquo;12&amp;rdquo;,&amp;ldquo;23&amp;rdquo;,&amp;ldquo;345&amp;rdquo;,&amp;ldquo;4567&amp;rdquo;),2)&lt;br&gt;
               z.aggregate(&amp;ldquo;&amp;rdquo;)((x,y) =&amp;gt; math.max(x.length, y.length).toString,
               (x,y) =&amp;gt; x + y)&lt;br&gt;
               res141: String = 42&lt;br&gt;
               &lt;br&gt;
               z.aggregate(&amp;ldquo;&amp;rdquo;)((x,y) =&amp;gt; math.min(x.length, y.length).toString,
               (x,y) =&amp;gt; x + y)&lt;br&gt;
               res142: String = 11&lt;br&gt;
               &lt;br&gt;
               val z = sc.parallelize(List(&amp;ldquo;12&amp;rdquo;,&amp;ldquo;23&amp;rdquo;,&amp;ldquo;345&amp;rdquo;,&amp;ldquo;&amp;rdquo;),2)&lt;br&gt;
               z.aggregate(&amp;ldquo;&amp;rdquo;)((x,y) =&amp;gt; math.min(x.length, y.length).toString,
               (x,y) =&amp;gt; x + y)&lt;br&gt;
               res143: String = 10
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;/span&gt;The main issue with the code above is that the result of
the inner &lt;span style=&quot;font-weight: bold;&quot;&gt;min&lt;/span&gt; is a string of
length 1. &lt;br&gt;
The zero in the output is due to the empty string being the last string
in the list. We see this result because we are not recursively reducing
any further within the partition for the final string.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Examples 2&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;/span&gt;&lt;br&gt;
   &lt;table style=&quot;text-align: left; width: 519px; height: 71px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               z = sc.parallelize(List(&amp;ldquo;12&amp;rdquo;,&amp;ldquo;23&amp;rdquo;,&amp;ldquo;&amp;rdquo;,&amp;ldquo;345&amp;rdquo;),2)&lt;br&gt;
               z.aggregate(&amp;ldquo;&amp;rdquo;)((x,y) =&amp;gt; math.min(x.length, y.length).toString,
               (x,y) =&amp;gt; x + y)&lt;br&gt;
               res144: String = 11
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
   &lt;br&gt;
&lt;/div&gt;
In contrast to the previous example, this example has the empty string
at the beginning of the second partition. This results in length of
zero being input to the second reduce which then upgrades it a length
of 1. &lt;span style=&quot;font-style: italic;&quot;&gt;(Warning: The above example
shows bad design since the output is dependent on the order of the data
inside the partitions.)&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;aggregateByKey&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;aggregateByKey&lt;/span&gt;&lt;/big&gt;&lt;/big&gt; [Pair]&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;text-align: left; width: 1799px;&quot;&gt;Works like the
   aggregate function except the aggregation is applied to the values with
   the same key. Also unlike the aggregate function the initial value is
   not applied to the second reduce.&lt;br&gt;
&lt;/div&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
   &lt;/span&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;&lt;br&gt;
&lt;/div&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def aggregateByKey&lt;a href=&quot;zeroValue:%20U&quot;&gt;U&lt;/a&gt;(seqOp: (U, V) ⇒ U, combOp: (U, U) ⇒ U)(implicit arg0: ClassTag[U]): RDD[(K, U)]&lt;br&gt;
   def aggregateByKey&lt;a href=&quot;zeroValue:%20U,%20numPartitions:%20Int&quot;&gt;U&lt;/a&gt;(seqOp: (U, V) ⇒
   U, combOp: (U, U) ⇒ U)(implicit arg0: ClassTag[U]): RDD[(K, U)]&lt;br&gt;
   def aggregateByKey&lt;a href=&quot;zeroValue:%20U,%20partitioner:%20Partitioner&quot;&gt;U&lt;/a&gt;(seqOp:
   (U, V) ⇒ U, combOp: (U, U) ⇒ U)(implicit arg0: ClassTag[U]): RDD[(K, U)]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;table style=&quot;text-align: left; width: 584px; margin-left: 40px; height: 25px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
   &lt;tbody&gt;
      &lt;tr&gt;
         &lt;td style=&quot;vertical-align: top;&quot;&gt;val pairRDD = sc.parallelize(List( (&amp;ldquo;cat&amp;rdquo;,2), (&amp;ldquo;cat&amp;rdquo;, 5), (&amp;ldquo;mouse&amp;rdquo;, 4),(&amp;ldquo;cat&amp;rdquo;, 12), (&amp;ldquo;dog&amp;rdquo;, 12), (&amp;ldquo;mouse&amp;rdquo;, 2)), 2)&lt;br&gt;
            &lt;br&gt;
            // lets have a look at what is in the partitions&lt;br&gt;
            def myfunc(index: Int, iter: Iterator[(String, Int)]) : Iterator[String] = {&lt;br&gt;
            &amp;nbsp; iter.toList.map(x =&amp;gt; &amp;ldquo;[partID:&amp;rdquo; +&amp;nbsp; index + &amp;ldquo;, val: &amp;rdquo; + x + &amp;ldquo;]&amp;rdquo;).iterator&lt;br&gt;
            }&lt;br&gt;
            pairRDD.mapPartitionsWithIndex(myfunc).collect&lt;br&gt;
            &lt;br&gt;
            res2: Array[String] = Array([partID:0, val: (cat,2)], [partID:0, val:
            (cat,5)], [partID:0, val: (mouse,4)], [partID:1, val: (cat,12)],
            [partID:1, val: (dog,12)], [partID:1, val: (mouse,2)])&lt;br&gt;
            &lt;br&gt;
            pairRDD.aggregateByKey(0)(math.max(&lt;em&gt;, _), _ + _).collect&lt;br&gt;
            res3: Array[(String, Int)] = Array((dog,12), (cat,17), (mouse,6))&lt;br&gt;
            &lt;br&gt;
            pairRDD.aggregateByKey(100)(math.max(&lt;/em&gt;, &lt;em&gt;), _ + &lt;em&gt;).collect&lt;br&gt;
            res4: Array[(String, Int)] = Array((dog,100), (cat,200), (mouse,200))&lt;br&gt;
            &lt;br&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
   &lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;a name=&quot;cartesian&quot;&gt;&lt;/a&gt;&lt;br style=&quot;font-weight: bold;&quot;&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;cartesian&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;text-align: left;&quot;&gt;Computes the cartesian product
   between two RDDs (i.e. Each item of the first RDD is joined with each
   item of the second RDD) and returns them as a new RDD. &lt;span style=&quot;font-style: italic;&quot;&gt;(Warning: Be careful when using this
   function.! Memory consumption can quickly become an issue!)&lt;/span&gt;&lt;br&gt;
&lt;/div&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
   &lt;/span&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;&lt;br&gt;
&lt;/div&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def cartesian&lt;a href=&quot;other:%0A%20%20%20RDD%5BU%5D&quot;&gt;U: ClassTag&lt;/a&gt;: RDD[(T, U)]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;/span&gt;&lt;br&gt;
   &lt;table style=&quot;text-align: left; width: 522px; height: 108px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               x = sc.parallelize(List(1,2,3,4,5))&lt;br&gt;
               val y = sc.parallelize(List(6,7,8,9,10))&lt;br&gt;
               x.cartesian(y).collect&lt;br&gt;
               res0: Array[(Int, Int)] = Array((1,6), (1,7), (1,8), (1,9), (1,10),
               (2,6), (2,7), (2,8), (2,9), (2,10), (3,6), (3,7), (3,8), (3,9), (3,10),
               (4,6), (5,6), (4,7), (5,7), (4,8), (5,8), (4,9), (4,10), (5,9), (5,10))
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
   &lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;checkpoint&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big style=&quot;font-weight: bold;&quot;&gt;&lt;big&gt;checkpoint&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Will create a checkpoint when the RDD is computed next. Checkpointed
RDDs are stored as a binary file within the checkpoint directory which
can be specified using the Spark context.&lt;span style=&quot;font-style: italic;&quot;&gt; (Warning: Spark applies lazy evaluation.
Checkpointing will not occur until an action is invoked.)&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
Important note: the directory&amp;nbsp; &amp;ldquo;my_directory_name&amp;rdquo; should exist in
all slaves. As an alternative you could use an HDFS directory URL as
well.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;&lt;br&gt;
&lt;/div&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def checkpoint()&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;/span&gt;&lt;br&gt;
   &lt;table style=&quot;text-align: left; width: 522px; height: 108px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;sc.setCheckpointDir(&amp;ldquo;my_directory_name&amp;rdquo;)&lt;br&gt;
               val a = sc.parallelize(1 to 4)&lt;br&gt;
               a.checkpoint&lt;br&gt;
               a.count&lt;br&gt;
               14/02/25 18:13:53 INFO SparkContext: Starting job: count at
               &amp;lt;console&amp;gt;:15&lt;br&gt;
               &amp;hellip;&lt;br&gt;
               14/02/25 18:13:53 INFO MemoryStore: Block broadcast_5 stored as values
               to memory (estimated size 115.7 KB, free 296.3 MB)&lt;br&gt;
               14/02/25 18:13:53 INFO RDDCheckpointData: Done checkpointing RDD 11 to
               file:/home/cloudera/Documents/spark-0.9.0-incubating-bin-cdh4/bin/my&lt;/em&gt;directory_name/65407913-fdc6-4ec1-82c9-48a1656b95d6/rdd-11,
               new parent is RDD 12&lt;br&gt;
               res23: Long = 4
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;p class=&quot;p30 ft4&quot;&gt;&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;a name=&quot;coalesce&quot;&gt;&lt;/a&gt;&lt;br&gt;
   &lt;/span&gt;&lt;/big&gt;&lt;/big&gt;
&lt;/p&gt;
&lt;p class=&quot;p30 ft4&quot;&gt;&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;coalesce,
   repartition&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
   &lt;br&gt;
&lt;/p&gt;
&lt;div style=&quot;text-align: left;&quot;&gt;Coalesces the associated data into
   a given number of partitions. &lt;span style=&quot;font-style: italic;&quot;&gt;repartition(numPartitions)&lt;/span&gt;
   is simply an abbreviation for &lt;span style=&quot;font-style: italic;&quot;&gt;coalesce(numPartitions,
   shuffle = true)&lt;/span&gt;.&lt;br&gt;
&lt;/div&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
   &lt;/span&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def coalesce ( numPartitions :
   Int , shuffle : Boolean = false ): RDD [T]&lt;br&gt;
   def repartition ( numPartitions : Int ): RDD [T] 
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 522px; height: 108px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               y = sc.parallelize(1 to 10, 10)&lt;br&gt;
               val z = y.coalesce(2, false)&lt;br&gt;
               z.partitions.length&lt;br&gt;
               res9: Int = 2
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;cogroup&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;p class=&quot;p30 ft4&quot;&gt;&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;cogroup
   &lt;small&gt;[Pair]&lt;/small&gt;, groupWith &lt;small&gt;[Pair]&lt;/small&gt;&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
   &lt;br&gt;
&lt;/p&gt;
&lt;div style=&quot;text-align: left;&quot;&gt;A very powerful set of functions
   that allow grouping up to 3 key-value RDDs together using their keys.&lt;br&gt;
&lt;/div&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
   &lt;/span&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def cogroup&lt;a href=&quot;other:%20RDD%5B(K,%0A%20%20%20W)%5D&quot;&gt;W&lt;/a&gt;: RDD[(K, (Iterable[V], Iterable[W]))]&lt;br&gt;
   def cogroup&lt;a href=&quot;other:%20RDD%5B(K,%20W)%5D,%20numPartitions:%20Int&quot;&gt;W&lt;/a&gt;: RDD[(K,
   (Iterable[V], Iterable[W]))]&lt;br&gt;
   def cogroup&lt;a href=&quot;other:%20RDD%5B(K,%20W)%5D,%20partitioner:%20Partitioner&quot;&gt;W&lt;/a&gt;: RDD[(K,
   (Iterable[V], Iterable[W]))]&lt;br&gt;
   def cogroup&lt;a href=&quot;other1:%20RDD%5B(K,%20W1)%5D,%20other2:%20RDD%5B(K,%20W2)%5D&quot;&gt;W1, W2&lt;/a&gt;:
   RDD[(K, (Iterable[V], Iterable[W1], Iterable[W2]))]&lt;br&gt;
   def cogroup&lt;a href=&quot;other1:%20RDD%5B(K,%20W1)%5D,%20other2:%20RDD%5B(K,%20W2)%5D,%0A%20%20%20numPartitions:%20Int&quot;&gt;W1, W2&lt;/a&gt;: RDD[(K, (Iterable[V], Iterable[W1], Iterable[W2]))]&lt;br&gt;
   def cogroup&lt;a href=&quot;other1:%20RDD%5B(K,%20W1)%5D,%20other2:%20RDD%5B(K,%20W2)%5D,%0A%20%20%20partitioner:%20Partitioner&quot;&gt;W1, W2&lt;/a&gt;: RDD[(K, (Iterable[V], Iterable[W1],
   Iterable[W2]))]&lt;br&gt;
   def groupWith&lt;a href=&quot;other:%20RDD%5B(K,%20W)%5D&quot;&gt;W&lt;/a&gt;: RDD[(K, (Iterable[V],
   Iterable[W]))]&lt;br&gt;
   def groupWith&lt;a href=&quot;other1:%20RDD%5B(K,%20W1)%5D,%20other2:%20RDD%5B(K,%20W2)%5D&quot;&gt;W1, W2&lt;/a&gt;:
   RDD[(K, (Iterable[V], IterableW1], Iterable[W2]))] 
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;s&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 522px; height: 108px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(List(1, 2, 1, 3), 1)&lt;br&gt;
               val b = a.map((&lt;/em&gt;, &amp;ldquo;b&amp;rdquo;))&lt;br&gt;
               val c = a.map((&lt;em&gt;, &amp;ldquo;c&amp;rdquo;))&lt;br&gt;
               b.cogroup&amp;copy;.collect&lt;br&gt;
               res7: Array[(Int, (Iterable[String], Iterable[String]))] = Array(&lt;br&gt;
               (2,(ArrayBuffer(b),ArrayBuffer&amp;copy;)),&lt;br&gt;
               (3,(ArrayBuffer(b),ArrayBuffer&amp;copy;)),&lt;br&gt;
               (1,(ArrayBuffer(b, b),ArrayBuffer(c, c)))&lt;br&gt;
               )&lt;br&gt;
               &lt;br&gt;
               val d = a.map((&lt;/em&gt;, &amp;ldquo;d&amp;rdquo;))&lt;br&gt;
               b.cogroup(c, d).collect&lt;br&gt;
               res9: Array[(Int, (Iterable[String], Iterable[String],
               Iterable[String]))] = Array(&lt;br&gt;
               (2,(ArrayBuffer(b),ArrayBuffer&amp;copy;,ArrayBuffer(d))),&lt;br&gt;
               (3,(ArrayBuffer(b),ArrayBuffer&amp;copy;,ArrayBuffer(d))),&lt;br&gt;
               (1,(ArrayBuffer(b, b),ArrayBuffer(c, c),ArrayBuffer(d, d)))&lt;br&gt;
               )&lt;br&gt;
               &lt;br&gt;
               val x = sc.parallelize(List((1, &amp;ldquo;apple&amp;rdquo;), (2, &amp;ldquo;banana&amp;rdquo;), (3, &amp;ldquo;orange&amp;rdquo;),
               (4, &amp;ldquo;kiwi&amp;rdquo;)), 2)&lt;br&gt;
               val y = sc.parallelize(List((5, &amp;ldquo;computer&amp;rdquo;), (1, &amp;ldquo;laptop&amp;rdquo;), (1,
               &amp;ldquo;desktop&amp;rdquo;), (4, &amp;ldquo;iPad&amp;rdquo;)), 2)&lt;br&gt;
               x.cogroup(y).collect&lt;br&gt;
               res23: Array[(Int, (Iterable[String], Iterable[String]))] = Array(&lt;br&gt;
               (4,(ArrayBuffer(kiwi),ArrayBuffer(iPad))), &lt;br&gt;
               (2,(ArrayBuffer(banana),ArrayBuffer())), &lt;br&gt;
               (3,(ArrayBuffer(orange),ArrayBuffer())),&lt;br&gt;
               (1,(ArrayBuffer(apple),ArrayBuffer(laptop, desktop))),&lt;br&gt;
               (5,(ArrayBuffer(),ArrayBuffer(computer))))
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;collect&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;p class=&quot;p30 ft4&quot;&gt;&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;collect,
   toArray&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
   &lt;br&gt;
&lt;/p&gt;
&lt;div style=&quot;text-align: left;&quot;&gt;Converts the RDD into a Scala
   array and returns it. If you provide a standard map-function (i.e. f =
   T -&amp;gt; U) it will be applied before inserting the values into the
   result array.&lt;br&gt;
&lt;/div&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
   &lt;/span&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def collect(): Array[T]&lt;br&gt;
   def collect&lt;a href=&quot;f:%20PartialFunction%5BT,%20U%5D&quot;&gt;U: ClassTag&lt;/a&gt;: RDD[U]&lt;br&gt;
   def toArray(): Array[T] 
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 522px; height: 62px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               c = sc.parallelize(List(&amp;ldquo;Gnu&amp;rdquo;, &amp;ldquo;Cat&amp;rdquo;, &amp;ldquo;Rat&amp;rdquo;, &amp;ldquo;Dog&amp;rdquo;, &amp;ldquo;Gnu&amp;rdquo;, &amp;ldquo;Rat&amp;rdquo;), 2)&lt;br&gt;
               c.collect&lt;br&gt;
               res29: Array[String] = Array(Gnu, Cat, Rat, Dog, Gnu, Rat)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;collectAsMap&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;p class=&quot;p30 ft4&quot;&gt;&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;collectAsMap
   &lt;small&gt;[Pair]&lt;/small&gt; &lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
   &lt;br&gt;
&lt;/p&gt;
&lt;div style=&quot;text-align: left;&quot;&gt;Similar to &lt;span style=&quot;font-style: italic;&quot;&gt;collect&lt;/span&gt;, but works on key-value
   RDDs and converts them into Scala maps to preserve their key-value
   structure.&lt;br&gt;
&lt;/div&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
   &lt;/span&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def collectAsMap(): Map[K, V] &lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 522px; height: 62px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(List(1, 2, 1, 3), 1)&lt;br&gt;
               val b = a.zip(a)&lt;br&gt;
               b.collectAsMap&lt;br&gt;
               res1: scala.collection.Map[Int,Int] = Map(2 -&amp;gt; 2, 1 -&amp;gt; 1, 3 -&amp;gt;
               3)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;combineByKey&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;p class=&quot;p30 ft4&quot;&gt;&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;combineByKey[Pair]
   &lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
   &lt;br&gt;
&lt;/p&gt;
&lt;div style=&quot;text-align: left;&quot;&gt;Very efficient implementation that
   combines the values of a RDD consisting of two-component tuples by
   applying multiple aggregators one after another.&lt;br&gt;
&lt;/div&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
   &lt;/span&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def
   combineByKey&lt;a href=&quot;createCombiner:%20V%20=&amp;amp;gt;%20C,%20mergeValue:%20(C,%20V)%20=&amp;amp;gt;%20C,%0A%20%20%20mergeCombiners:%20(C,%20C)%20=&amp;amp;gt;%20C&quot;&gt;C&lt;/a&gt;: RDD[(K, C)]&lt;br&gt;
   def combineByKey&lt;a href=&quot;createCombiner:%20V%20=&amp;amp;gt;%20C,%20mergeValue:%20(C,%20V)%20=&amp;amp;gt;%0A%20%20%20C,%20mergeCombiners:%20(C,%20C)%20=&amp;amp;gt;%20C,%20numPartitions:%20Int&quot;&gt;C&lt;/a&gt;: RDD[(K, C)]&lt;br&gt;
   def combineByKey&lt;a href=&quot;createCombiner:%20V%20=&amp;amp;gt;%20C,%20mergeValue:%20(C,%20V)%20=&amp;amp;gt;%0A%20%20%20C,%20mergeCombiners:%20(C,%20C)%20=&amp;amp;gt;%20C,%20partitioner:%20Partitioner,%0A%20%20%20mapSideCombine:%20Boolean%20=%20true,%20serializerClass:%20String%20=%20null&quot;&gt;C&lt;/a&gt;:
   RDD[(K, C)] 
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 153px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a =
               sc.parallelize(List(&amp;ldquo;dog&amp;rdquo;,&amp;ldquo;cat&amp;rdquo;,&amp;ldquo;gnu&amp;rdquo;,&amp;ldquo;salmon&amp;rdquo;,&amp;ldquo;rabbit&amp;rdquo;,&amp;ldquo;turkey&amp;rdquo;,&amp;ldquo;wolf&amp;rdquo;,&amp;ldquo;bear&amp;rdquo;,&amp;ldquo;bee&amp;rdquo;),
               3)&lt;br&gt;
               val b = sc.parallelize(List(1,1,2,2,2,1,2,2,2), 3)&lt;br&gt;
               val c = b.zip(a)&lt;br&gt;
               val d = c.combineByKey(List(&lt;em&gt;), (x:List[String], y:String) =&amp;gt; y ::
               x, (x:List[String], y:List[String]) =&amp;gt; x ::: y)&lt;br&gt;
               d.collect&lt;br&gt;
               res16: Array[(Int, List[String])] = Array((1,List(cat, dog, turkey)),
               (2,List(gnu, rabbit, salmon, bee, bear, wolf)))
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;compute&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;p class=&quot;p30 ft4&quot;&gt;&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;compute&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;/p&gt;
&lt;div style=&quot;text-align: left;&quot;&gt;Executes dependencies and computes
   the actual representation of the RDD. This function should not be
   called directly by users.&lt;br&gt;
&lt;/div&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
   &lt;/span&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def compute(split: Partition,
   context: TaskContext): Iterator[T] 
&lt;/div&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;p class=&quot;p30 ft4&quot;&gt;&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;a name=&quot;context&quot;&gt;&lt;/a&gt;&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;/p&gt;
&lt;p class=&quot;p30 ft4&quot;&gt;&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;context,
   sparkContext&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;/p&gt;
&lt;div style=&quot;text-align: left;&quot;&gt;Returns the &lt;span style=&quot;font-style: italic;&quot;&gt;SparkContext&lt;/span&gt; that was used to
   create the RDD.&lt;br&gt;
&lt;/div&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
   &lt;/span&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def compute(split: Partition,
   context: TaskContext): Iterator[T] 
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 65px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               c = sc.parallelize(List(&amp;ldquo;Gnu&amp;rdquo;, &amp;ldquo;Cat&amp;rdquo;, &amp;ldquo;Rat&amp;rdquo;, &amp;ldquo;Dog&amp;rdquo;), 2)&lt;br&gt;
               c.context&lt;br&gt;
               res8: org.apache.spark.SparkContext =
               org.apache.spark.SparkContext@58c1c2f1
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;count&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;p class=&quot;p30 ft4&quot;&gt;&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;count&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;/p&gt;
&lt;div style=&quot;text-align: left;&quot;&gt;Returns the number of items stored
   within a RDD.&lt;br&gt;
&lt;/div&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
   &lt;/span&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def count(): Long &lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 65px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               c = sc.parallelize(List(&amp;ldquo;Gnu&amp;rdquo;, &amp;ldquo;Cat&amp;rdquo;, &amp;ldquo;Rat&amp;rdquo;, &amp;ldquo;Dog&amp;rdquo;), 2)&lt;br&gt;
               c.count&lt;br&gt;
               res2: Long = 4
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;countApprox&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;p class=&quot;p30 ft4&quot;&gt;&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;countApprox&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;/p&gt;
Marked as experimental feature! Experimental features are currently not
covered by this document!
&lt;div style=&quot;margin-left: 40px;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
   &lt;/span&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def (timeout: Long, confidence:
   Double = 0.95): PartialResult[BoundedDouble]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;countApproxDistinct&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;countApproxDistinct&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Computes the approximate number of distinct values. For large RDDs
which are spread across many nodes, this function may execute faster
than other counting methods. The parameter &lt;span style=&quot;font-style: italic;&quot;&gt;relativeSD&lt;/span&gt; controls the accuracy of
the computation.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def
   countApproxDistinct(relativeSD: Double = 0.05): Long&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 65px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(1 to 10000, 20)&lt;br&gt;
               val b = a++a++a++a++a&lt;br&gt;
               b.countApproxDistinct(0.1)&lt;br&gt;
               res14: Long = 8224&lt;br&gt;
               &lt;br&gt;
               b.countApproxDistinct(0.05)&lt;br&gt;
               res15: Long = 9750&lt;br&gt;
               &lt;br&gt;
               b.countApproxDistinct(0.01)&lt;br&gt;
               res16: Long = 9947&lt;br&gt;
               &lt;br&gt;
               b.countApproxDistinct(0.001)&lt;br&gt;
               res0: Long = 10000&lt;br&gt;
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;countApproxDistinceByKey&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;countApproxDistinctByKey
&lt;small&gt;[Pair]&lt;/small&gt;&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&amp;nbsp; &lt;br&gt;
Similar to &lt;span style=&quot;font-style: italic;&quot;&gt;countApproxDistinct&lt;/span&gt;,
but computes the approximate number of distinct values for each
distinct key. Hence, the RDD must consist of two-component tuples. For
large RDDs which are spread across many nodes, this function may
execute faster than other counting methods. The parameter &lt;span style=&quot;font-style: italic;&quot;&gt;relativeSD&lt;/span&gt; controls the accuracy of
the computation.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def
   countApproxDistinctByKey(relativeSD: Double = 0.05): RDD[(K, Long)]&lt;br&gt;
   def countApproxDistinctByKey(relativeSD: Double, numPartitions: Int):
   RDD[(K, Long)]&lt;br&gt;
   def countApproxDistinctByKey(relativeSD: Double, partitioner:
   Partitioner): RDD[(K, Long)]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 65px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(List(&amp;ldquo;Gnu&amp;rdquo;, &amp;ldquo;Cat&amp;rdquo;, &amp;ldquo;Rat&amp;rdquo;, &amp;ldquo;Dog&amp;rdquo;), 2)&lt;br&gt;
               val b = sc.parallelize(a.takeSample(true, 10000, 0), 20)&lt;br&gt;
               val c = sc.parallelize(1 to b.count().toInt, 20)&lt;br&gt;
               val d = b.zip&amp;copy;&lt;br&gt;
               d.countApproxDistinctByKey(0.1).collect&lt;br&gt;
               res15: Array[(String, Long)] = Array((Rat,2567), (Cat,3357),
               (Dog,2414), (Gnu,2494))&lt;br&gt;
               &lt;br&gt;
               d.countApproxDistinctByKey(0.01).collect&lt;br&gt;
               res16: Array[(String, Long)] = Array((Rat,2555), (Cat,2455),
               (Dog,2425), (Gnu,2513))&lt;br&gt;
               &lt;br&gt;
               d.countApproxDistinctByKey(0.001).collect&lt;br&gt;
               res0: Array[(String, Long)] = Array((Rat,2562), (Cat,2464), (Dog,2451),
               (Gnu,2521))
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;countByKey&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;p class=&quot;p30 ft4&quot;&gt;&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;countByKey
   &lt;small&gt;[Pair]&lt;/small&gt;&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;/p&gt;
Very similar to count, but counts the values of a RDD consisting of
two-component tuples for each distinct key separately.
&lt;div style=&quot;margin-left: 40px;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
   &lt;/span&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def countByKey(): Map[K, Long]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 65px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               c = sc.parallelize(List((3, &amp;ldquo;Gnu&amp;rdquo;), (3, &amp;ldquo;Yak&amp;rdquo;), (5, &amp;ldquo;Mouse&amp;rdquo;), (3,
               &amp;ldquo;Dog&amp;rdquo;)), 2)&lt;br&gt;
               c.countByKey&lt;br&gt;
               res3: scala.collection.Map[Int,Long] = Map(3 -&amp;gt; 3, 5 -&amp;gt; 1)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;br&gt;
&lt;a name=&quot;countByKeyApprox&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;p class=&quot;p30 ft4&quot;&gt;&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;countByKeyApprox
   &lt;small&gt;[Pair]&lt;/small&gt;&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;/p&gt;
Marked as experimental feature! Experimental features are currently not
covered by this document!
&lt;div style=&quot;margin-left: 40px;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
   &lt;/span&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def countByKeyApprox(timeout:
   Long, confidence: Double = 0.95): PartialResult[Map[K, BoundedDouble]]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;a name=&quot;countByValue&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;countByValue&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Returns a map that contains all unique values of the RDD and their
respective occurrence counts.&lt;span style=&quot;font-style: italic;&quot;&gt;
(Warning: This operation will finally aggregate the information in a
single reducer.)&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def countByValue(): Map[T, Long]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 65px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               b = sc.parallelize(List(1,2,3,4,5,6,7,8,2,4,2,1,1,1,1,1))&lt;br&gt;
               b.countByValue&lt;br&gt;
               res27: scala.collection.Map[Int,Long] = Map(5 -&amp;gt; 1, 8 -&amp;gt; 1, 3
               -&amp;gt; 1, 6 -&amp;gt; 1, 1 -&amp;gt; 6, 2 -&amp;gt; 3, 4 -&amp;gt; 2, 7 -&amp;gt; 1)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;countByValueApprox&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;p class=&quot;p30 ft4&quot;&gt;&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;countByValueApprox&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;/p&gt;
Marked as experimental feature! Experimental features are currently not
covered by this document!
&lt;div style=&quot;margin-left: 40px;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
   &lt;/span&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def countByValueApprox(timeout:
   Long, confidence: Double = 0.95): PartialResult[Map[T, BoundedDouble]]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;dependencies&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;dependencies&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&amp;nbsp; &lt;br&gt;
Returns the RDD on which this RDD depends.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;final def dependencies:
   Seq[Dependency[&lt;/em&gt;]]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 65px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               b = sc.parallelize(List(1,2,3,4,5,6,7,8,2,4,2,1,1,1,1,1))&lt;br&gt;
               b: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[32] at
               parallelize at &amp;lt;console&amp;gt;:12&lt;br&gt;
               b.dependencies.length&lt;br&gt;
               Int = 0&lt;br&gt;
               &lt;br&gt;
               b.map(a =&amp;gt; a).dependencies.length&lt;br&gt;
               res40: Int = 1&lt;br&gt;
               &lt;br&gt;
               b.cartesian(a).dependencies.length&lt;br&gt;
               res41: Int = 2&lt;br&gt;
               &lt;br&gt;
               b.cartesian(a).dependencies&lt;br&gt;
               res42: Seq[org.apache.spark.Dependency[&lt;em&gt;]] =
               List(org.apache.spark.rdd.CartesianRDD$$anon$1@576ddaaa,
               org.apache.spark.rdd.CartesianRDD$$anon$2@6d2efbbd)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;distinct&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;distinct&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&amp;nbsp; &lt;br&gt;
Returns a new RDD that contains each unique value only once.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def distinct(): RDD[T]&lt;br&gt;
   def distinct(numPartitions: Int): RDD[T]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 65px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               c = sc.parallelize(List(&amp;ldquo;Gnu&amp;rdquo;, &amp;ldquo;Cat&amp;rdquo;, &amp;ldquo;Rat&amp;rdquo;, &amp;ldquo;Dog&amp;rdquo;, &amp;ldquo;Gnu&amp;rdquo;, &amp;ldquo;Rat&amp;rdquo;), 2)&lt;br&gt;
               c.distinct.collect&lt;br&gt;
               res6: Array[String] = Array(Dog, Gnu, Cat, Rat)&lt;br&gt;
               &lt;br&gt;
               val a = sc.parallelize(List(1,2,3,4,5,6,7,8,9,10))&lt;br&gt;
               a.distinct(2).partitions.length&lt;br&gt;
               res16: Int = 2&lt;br&gt;
               &lt;br&gt;
               a.distinct(3).partitions.length&lt;br&gt;
               res17: Int = 3
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;br&gt;
&lt;a name=&quot;first&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;first&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&amp;nbsp; &lt;br&gt;
Looks for the very first data item of the RDD and returns it.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def first(): T&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 65px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               c = sc.parallelize(List(&amp;ldquo;Gnu&amp;rdquo;, &amp;ldquo;Cat&amp;rdquo;, &amp;ldquo;Rat&amp;rdquo;, &amp;ldquo;Dog&amp;rdquo;), 2)&lt;br&gt;
               c.first&lt;br&gt;
               res1: String = Gnu
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;filter&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;filter&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&amp;nbsp; &lt;br&gt;
Evaluates a boolean function for each data item of the RDD and puts the
items for which the function returned &lt;span style=&quot;font-style: italic;&quot;&gt;true&lt;/span&gt;
into the resulting RDD.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def filter(f: T =&amp;gt; Boolean):
   RDD[T]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 65px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(1 to 10, 3)&lt;br&gt;
               val b = a.filter(&lt;/em&gt; % 2 == 0)&lt;br&gt;
               b.collect&lt;br&gt;
               res3: Array[Int] = Array(2, 4, 6, 8, 10)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
When you provide a filter function, it must be able to handle all data
items contained in the RDD. Scala provides so-called partial functions
to deal with mixed data-types. (Tip: Partial functions are very useful
if you have some data which may be bad and you do not want to handle
but for the good data (matching data) you want to apply some kind of
map function. The following article is good. It teaches you about
partial functions in a very nice way and explains why case has to be
used for partial functions:&amp;nbsp;&amp;nbsp;&lt;a href=&quot;http://blog.bruchez.name/2011/10/scala-partial-functions-without-phd.html&quot;&gt;article&lt;/a&gt;)&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Examples for mixed data without
partial functions&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 65px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               b = sc.parallelize(1 to 8)&lt;br&gt;
               b.filter(_ &amp;lt; 4).collect&lt;br&gt;
               res15: Array[Int] = Array(1, 2, 3)&lt;br&gt;
               &lt;br&gt;
               val a = sc.parallelize(List(&amp;ldquo;cat&amp;rdquo;, &amp;ldquo;horse&amp;rdquo;, 4.0, 3.5, 2, &amp;ldquo;dog&amp;rdquo;))&lt;br&gt;
               a.filter(_ &amp;lt; 4).collect&lt;br&gt;
               &amp;lt;console&amp;gt;:15: error: value &amp;lt; is not a member of Any
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
This fails because some components of &lt;span style=&quot;font-style: italic;&quot;&gt;a
&lt;/span&gt;are not implicitly comparable against integers. Collect
uses the &lt;span style=&quot;font-style: italic;&quot;&gt;isDefinedAt &lt;/span&gt;property
of a function-object to determine whether the test-function is
compatible with each data item. Only data items that pass this test &lt;span style=&quot;font-style: italic;&quot;&gt;(=filter) &lt;/span&gt;are then mapped using
the function-object.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Examples for mixed data with
partial functions&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 65px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(List(&amp;ldquo;cat&amp;rdquo;, &amp;ldquo;horse&amp;rdquo;, 4.0, 3.5, 2, &amp;ldquo;dog&amp;rdquo;))&lt;br&gt;
               a.collect({case a: Int&amp;nbsp;&amp;nbsp;&amp;nbsp; =&amp;gt; &amp;ldquo;is integer&amp;rdquo; |&lt;br&gt;
               &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; case b:
               String =&amp;gt; &amp;ldquo;is string&amp;rdquo; }).collect&lt;br&gt;
               res17: Array[String] = Array(is string, is string, is integer, is
               string)&lt;br&gt;
               &lt;br&gt;
               val myfunc: PartialFunction[Any, Any] = {&lt;br&gt;
               &amp;nbsp; case a: Int&amp;nbsp;&amp;nbsp;&amp;nbsp; =&amp;gt; &amp;ldquo;is integer&amp;rdquo; |&lt;br&gt;
               &amp;nbsp; case b: String =&amp;gt; &amp;ldquo;is string&amp;rdquo; }&lt;br&gt;
               myfunc.isDefinedAt(&amp;ldquo;&amp;rdquo;)&lt;br&gt;
               res21: Boolean = true&lt;br&gt;
               &lt;br&gt;
               myfunc.isDefinedAt(1)&lt;br&gt;
               res22: Boolean = true&lt;br&gt;
               &lt;br&gt;
               myfunc.isDefinedAt(1.5)&lt;br&gt;
               res23: Boolean = false
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
Be careful! The above code works because it only checks the type
itself! If you use operations on this type, you have to explicitly
declare what type you want instead of any. Otherwise the compiler does
(apparently) not know what bytecode it should produce:&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 65px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               myfunc2: PartialFunction[Any, Any] = {case x if (x &amp;lt; 4) =&amp;gt; &amp;ldquo;x&amp;rdquo;}&lt;br&gt;
               &amp;lt;console&amp;gt;:10: error: value &amp;lt; is not a member of Any&lt;br&gt;
               &lt;br&gt;
               val myfunc2: PartialFunction[Int, Any] = {case x if (x &amp;lt; 4) =&amp;gt;
               &amp;ldquo;x&amp;rdquo;}&lt;br&gt;
               myfunc2: PartialFunction[Int,Any] = &amp;lt;function1&amp;gt;
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;filterByRange&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;filterByRange &lt;/span&gt;&lt;/big&gt;&lt;/big&gt;[Ordered]&lt;br&gt;
&amp;nbsp; &lt;br&gt;
Returns an RDD containing only the items in the key range specified.
From our testing, it appears this only works if your data is in key
value pairs and it has already been sorted by key.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def filterByRange(lower: K, upper: K): RDD[P]&lt;br&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;table style=&quot;text-align: left; width: 643px; margin-left: 40px; height: 33px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
   &lt;tbody&gt;
      &lt;tr&gt;
         &lt;td style=&quot;vertical-align: top;&quot;&gt;val randRDD = sc.parallelize(List( (2,&amp;ldquo;cat&amp;rdquo;), (6, &amp;ldquo;mouse&amp;rdquo;),(7, &amp;ldquo;cup&amp;rdquo;), (3, &amp;ldquo;book&amp;rdquo;), (4, &amp;ldquo;tv&amp;rdquo;), (1, &amp;ldquo;screen&amp;rdquo;), (5, &amp;ldquo;heater&amp;rdquo;)), 3)&lt;br&gt;
            val sortedRDD = randRDD.sortByKey()&lt;br&gt;
            &lt;br&gt;
            sortedRDD.filterByRange(1, 3).collect&lt;br&gt;
            res66: Array[(Int, String)] = Array((1,screen), (2,cat), (3,book))&lt;br&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
   &lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;filterWith&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;filterWith&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&amp;nbsp; &lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;(deprecated)&lt;/span&gt;&lt;/big&gt;&lt;br&gt;
&amp;nbsp; &lt;br&gt;
This is an extended version of &lt;span style=&quot;font-style: italic;&quot;&gt;filter&lt;/span&gt;.
It takes two function arguments. The first argument must conform to &lt;span style=&quot;font-style: italic;&quot;&gt;Int -&amp;gt; T&lt;/span&gt; and is executed once
per partition. It will transform the partition index to type &lt;span style=&quot;font-style: italic;&quot;&gt;T&lt;/span&gt;. The second function looks like&lt;span style=&quot;font-style: italic;&quot;&gt; (U, T) -&amp;gt; Boolean&lt;/span&gt;. &lt;span style=&quot;font-style: italic;&quot;&gt;T&lt;/span&gt; is the transformed partition
index and &lt;span style=&quot;font-style: italic;&quot;&gt;U&lt;/span&gt; are the data
items from the RDD. Finally the function has to return either true or
false &lt;span style=&quot;font-style: italic;&quot;&gt;(i.e. Apply the filter)&lt;/span&gt;.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def filterWith&lt;a href=&quot;constructA:%20Int%20=&amp;amp;gt;%20A&quot;&gt;A:
   ClassTag&lt;/a&gt;(p: (T, A) =&amp;gt; Boolean): RDD[T]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 65px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(1 to 9, 3)&lt;br&gt;
               val b = a.filterWith(i =&amp;gt; i)((x,i) =&amp;gt; x % 2 == 0 || i % 2 == 0)&lt;br&gt;
               b.collect&lt;br&gt;
               res37: Array[Int] = Array(1, 2, 3, 4, 6, 7, 8, 9)&lt;br&gt;
               &lt;br&gt;
               val a = sc.parallelize(List(1,2,3,4,5,6,7,8,9,10), 5)&lt;br&gt;
               a.filterWith(x=&amp;gt; x)((a, b) =&amp;gt;&amp;nbsp; b == 0).collect&lt;br&gt;
               res30: Array[Int] = Array(1, 2)&lt;br&gt;
               &lt;br&gt;
               a.filterWith(x=&amp;gt; x)((a, b) =&amp;gt;&amp;nbsp; a % (b+1) == 0).collect&lt;br&gt;
               res33: Array[Int] = Array(1, 2, 4, 6, 8, 10)&lt;br&gt;
               &lt;br&gt;
               a.filterWith(x=&amp;gt; x.toString)((a, b) =&amp;gt;&amp;nbsp; b == &amp;ldquo;2&amp;rdquo;).collect&lt;br&gt;
               res34: Array[Int] = Array(5, 6)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;flatMap&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;flatMap&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&amp;nbsp; &lt;br&gt;
Similar to &lt;span style=&quot;font-style: italic;&quot;&gt;map&lt;/span&gt;, but allows
emitting more than one item in the map function.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def flatMap&lt;a href=&quot;f:%20T%0A%20%20%20=&amp;amp;gt;%20TraversableOnce%5BU%5D&quot;&gt;U: ClassTag&lt;/a&gt;: RDD[U]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 65px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(1 to 10, 5)&lt;br&gt;
               a.flatMap(1 to &lt;em&gt;).collect&lt;br&gt;
               res47: Array[Int] = Array(1, 1, 2, 1, 2, 3, 1, 2, 3, 4, 1, 2, 3, 4, 5,
               1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3,
               4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)&lt;br&gt;
               &lt;br&gt;
               sc.parallelize(List(1, 2, 3), 2).flatMap(x =&amp;gt; List(x, x, x)).collect&lt;br&gt;
               res85: Array[Int] = Array(1, 1, 1, 2, 2, 2, 3, 3, 3)&lt;br&gt;
               &lt;br&gt;
               // The program below generates a random number of copies (up to 10) of
               the items in the list.&lt;br&gt;
               val x&amp;nbsp; = sc.parallelize(1 to 10, 3)&lt;br&gt;
               x.flatMap(List.fill(scala.util.Random.nextInt(10))(&lt;/em&gt;)).collect&lt;br&gt;
               &lt;br&gt;
               res1: Array[Int] = Array(1, 2, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5,
               5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9,
               9, 10, 10, 10, 10, 10, 10, 10, 10)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;flatMapValues&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;flatMapValues&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&amp;nbsp; &lt;br&gt;
Very similar to &lt;span style=&quot;font-style: italic;&quot;&gt;mapValues&lt;/span&gt;,
but collapses the inherent structure of the values during mapping.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def flatMapValues&lt;a href=&quot;f:%20V%20=&amp;amp;gt;%0A%20%20%20TraversableOnce%5BU%5D&quot;&gt;U&lt;/a&gt;: RDD[(K, U)]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 65px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(List(&amp;ldquo;dog&amp;rdquo;, &amp;ldquo;tiger&amp;rdquo;, &amp;ldquo;lion&amp;rdquo;, &amp;ldquo;cat&amp;rdquo;, &amp;ldquo;panther&amp;rdquo;,
               &amp;ldquo;eagle&amp;rdquo;), 2)&lt;br&gt;
               val b = a.map(x =&amp;gt; (x.length, x))&lt;br&gt;
               b.flatMapValues(&amp;ldquo;x&amp;rdquo; + _ + &amp;ldquo;x&amp;rdquo;).collect&lt;br&gt;
               res6: Array[(Int, Char)] = Array((3,x), (3,d), (3,o), (3,g), (3,x),
               (5,x), (5,t), (5,i), (5,g), (5,e), (5,r), (5,x), (4,x), (4,l), (4,i),
               (4,o), (4,n), (4,x), (3,x), (3,c), (3,a), (3,t), (3,x), (7,x), (7,p),
               (7,a), (7,n), (7,t), (7,h), (7,e), (7,r), (7,x), (5,x), (5,e), (5,a),
               (5,g), (5,l), (5,e), (5,x))
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;flatMapWith&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;flatMapWith&lt;/span&gt;&lt;/big&gt;&lt;/big&gt; &lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;(deprecated)&lt;/span&gt;&lt;/big&gt;&lt;br&gt;
&amp;nbsp; &lt;br&gt;
Similar to &lt;span style=&quot;font-style: italic;&quot;&gt;flatMap&lt;/span&gt;, but
allows accessing the partition index or a derivative of the partition
index from within the flatMap-function.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def flatMapWith&lt;a href=&quot;constructA:%20Int%20=&amp;amp;gt;%20A,%20preservesPartitioning:%20Boolean%20=%0A%20%20%20false&quot;&gt;A: ClassTag, U:
   ClassTag&lt;/a&gt;(f: (T, A) =&amp;gt; Seq[U]): RDD[U]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 65px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(List(1,2,3,4,5,6,7,8,9), 3)&lt;br&gt;
               a.flatMapWith(x =&amp;gt; x, true)((x, y) =&amp;gt; List(y, x)).collect&lt;br&gt;
               res58: Array[Int] = Array(0, 1, 0, 2, 0, 3, 1, 4, 1, 5, 1, 6, 2, 7, 2,
               8, 2, 9)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;fold&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;fold&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&amp;nbsp; &lt;br&gt;
Aggregates the values of each partition. The aggregation variable
within each partition is initialized with &lt;span style=&quot;font-style: italic;&quot;&gt;zeroValue&lt;/span&gt;.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def fold(zeroValue: T)(op: (T, T)
   =&amp;gt; T): T&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 65px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(List(1,2,3), 3)&lt;br&gt;
               a.fold(0)(_ + &lt;em&gt;)&lt;br&gt;
               res59: Int = 6
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;foldByKey&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;foldByKey &lt;small&gt;[Pair]&lt;/small&gt;&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&amp;nbsp; &lt;br&gt;
Very similar to &lt;span style=&quot;font-style: italic;&quot;&gt;fold&lt;/span&gt;, but
performs the folding separately for each key of the RDD. This function
is only available if the RDD consists of two-component tuples.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def foldByKey(zeroValue: V)(func:
   (V, V) =&amp;gt; V): RDD[(K, V)]&lt;br&gt;
   def foldByKey(zeroValue: V, numPartitions: Int)(func: (V, V) =&amp;gt; V):
   RDD[(K, V)]&lt;br&gt;
   def foldByKey(zeroValue: V, partitioner: Partitioner)(func: (V, V)
   =&amp;gt; V): RDD[(K, V)]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 65px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(List(&amp;ldquo;dog&amp;rdquo;, &amp;ldquo;cat&amp;rdquo;, &amp;ldquo;owl&amp;rdquo;, &amp;ldquo;gnu&amp;rdquo;, &amp;ldquo;ant&amp;rdquo;), 2)&lt;br&gt;
               val b = a.map(x =&amp;gt; (x.length, x))&lt;br&gt;
               b.foldByKey(&amp;ldquo;&amp;rdquo;)(&lt;/em&gt; + &lt;em&gt;).collect&lt;br&gt;
               res84: Array[(Int, String)] = Array((3,dogcatowlgnuant)&lt;br&gt;
               &lt;br&gt;
               val a = sc.parallelize(List(&amp;ldquo;dog&amp;rdquo;, &amp;ldquo;tiger&amp;rdquo;, &amp;ldquo;lion&amp;rdquo;, &amp;ldquo;cat&amp;rdquo;, &amp;ldquo;panther&amp;rdquo;,
               &amp;ldquo;eagle&amp;rdquo;), 2)&lt;br&gt;
               val b = a.map(x =&amp;gt; (x.length, x))&lt;br&gt;
               b.foldByKey(&amp;ldquo;&amp;rdquo;)(&lt;/em&gt; + &lt;em&gt;).collect&lt;br&gt;
               res85: Array[(Int, String)] = Array((4,lion), (3,dogcat), (7,panther),
               (5,tigereagle))
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;foreach&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;foreach&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&amp;nbsp; &lt;br&gt;
Executes an parameterless function for each data item.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def foreach(f: T =&amp;gt; Unit)&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 65px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               c = sc.parallelize(List(&amp;ldquo;cat&amp;rdquo;, &amp;ldquo;dog&amp;rdquo;, &amp;ldquo;tiger&amp;rdquo;, &amp;ldquo;lion&amp;rdquo;, &amp;ldquo;gnu&amp;rdquo;,
               &amp;ldquo;crocodile&amp;rdquo;, &amp;ldquo;ant&amp;rdquo;, &amp;ldquo;whale&amp;rdquo;, &amp;ldquo;dolphin&amp;rdquo;, &amp;ldquo;spider&amp;rdquo;), 3)&lt;br&gt;
               c.foreach(x =&amp;gt; println(x + &amp;ldquo;s are yummy&amp;rdquo;))&lt;br&gt;
               lions are yummy&lt;br&gt;
               gnus are yummy&lt;br&gt;
               crocodiles are yummy&lt;br&gt;
               ants are yummy&lt;br&gt;
               whales are yummy&lt;br&gt;
               dolphins are yummy&lt;br&gt;
               spiders are yummy
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
   &lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;foreachPartition&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;foreachPartition&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&amp;nbsp; &lt;br&gt;
Executes an parameterless function for each partition. Access to the
data items contained in the partition is provided via the iterator
argument.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def foreachPartition(f:
   Iterator[T] =&amp;gt; Unit)&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 65px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               b = sc.parallelize(List(1, 2, 3, 4, 5, 6, 7, 8, 9), 3)&lt;br&gt;
               b.foreachPartition(x =&amp;gt; println(x.reduce(&lt;/em&gt; + &lt;em&gt;)))&lt;br&gt;
               6&lt;br&gt;
               15&lt;br&gt;
               24
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;foreachWith&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;foreachWith&lt;/span&gt;&lt;/big&gt;&lt;/big&gt; &lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;(Deprecated)&lt;/span&gt;&lt;/big&gt;&lt;br&gt;
&amp;nbsp; &lt;br&gt;
Executes an parameterless function for each partition. Access to the
data items contained in the partition is provided via the iterator
argument.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def foreachWith&lt;a href=&quot;constructA:%20Int%20=&amp;amp;gt;%20A&quot;&gt;A:
   ClassTag&lt;/a&gt;(f: (T, A) =&amp;gt; Unit)&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 65px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(1 to 9, 3)&lt;br&gt;
               a.foreachWith(i =&amp;gt; i)((x,i) =&amp;gt; if (x % 2 == 1 &amp;amp;&amp;amp; i % 2 ==
               0) println(x) )&lt;br&gt;
               1&lt;br&gt;
               3&lt;br&gt;
               7&lt;br&gt;
               9
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;fullOuterJoin&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;fullOuterJoin&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;/span&gt;&lt;/big&gt; [Pair]&lt;br&gt;
&amp;nbsp; &lt;br&gt;
Performs the full outer join between two paired RDDs.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def fullOuterJoin&lt;a href=&quot;other:%20RDD%5B(K,%20W)%5D,%20numPartitions:%20Int&quot;&gt;W&lt;/a&gt;: RDD[(K, (Option[V], Option[W]))]&lt;br&gt;
   def fullOuterJoin&lt;a href=&quot;other:%20RDD%5B(K,%20W)%5D&quot;&gt;W&lt;/a&gt;: RDD[(K, (Option[V], Option[W]))]&lt;br&gt;
   def fullOuterJoin&lt;a href=&quot;other:%20RDD%5B(K,%20W)%5D,%20partitioner:%20Partitioner&quot;&gt;W&lt;/a&gt;: RDD[(K, (Option[V], Option[W]))]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;table style=&quot;text-align: left; width: 637px; margin-left: 40px; height: 26px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
   &lt;tbody&gt;
      &lt;tr&gt;
         &lt;td style=&quot;vertical-align: top;&quot;&gt;val pairRDD1 = sc.parallelize(List( (&amp;ldquo;cat&amp;rdquo;,2), (&amp;ldquo;cat&amp;rdquo;, 5), (&amp;ldquo;book&amp;rdquo;, 4),(&amp;ldquo;cat&amp;rdquo;, 12)))&lt;br&gt;
            val pairRDD2 = sc.parallelize(List( (&amp;ldquo;cat&amp;rdquo;,2), (&amp;ldquo;cup&amp;rdquo;, 5), (&amp;ldquo;mouse&amp;rdquo;, 4),(&amp;ldquo;cat&amp;rdquo;, 12)))&lt;br&gt;
            pairRDD1.fullOuterJoin(pairRDD2).collect&lt;br&gt;
            &lt;br&gt;
            res5: Array[(String, (Option[Int], Option[Int]))] =
            Array((book,(Some(4),None)), (mouse,(None,Some(4))),
            (cup,(None,Some(5))), (cat,(Some(2),Some(2))),
            (cat,(Some(2),Some(12))), (cat,(Some(5),Some(2))),
            (cat,(Some(5),Some(12))), (cat,(Some(12),Some(2))),
            (cat,(Some(12),Some(12))))&lt;br&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
   &lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;generator&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;generator, setGenerator&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&amp;nbsp; &lt;br&gt;
Allows setting a string that is attached to the end of the RDD&amp;rsquo;s name
when printing the dependency graph.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;@transient var generator&lt;br&gt;
   def setGenerator(_generator: String)&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;getCheckpointFile&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;getCheckpointFile&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&amp;nbsp; &lt;br&gt;
Returns the path to the checkpoint file or null if RDD has not yet been
checkpointed.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def getCheckpointFile:
   Option[String]
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 65px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;sc.setCheckpointDir(&amp;ldquo;/home/cloudera/Documents&amp;rdquo;)&lt;br&gt;
               val a = sc.parallelize(1 to 500, 5)&lt;br&gt;
               val b = a++a++a++a++a&lt;br&gt;
               b.getCheckpointFile&lt;br&gt;
               res49: Option[String] = None&lt;br&gt;
               &lt;br&gt;
               b.checkpoint&lt;br&gt;
               b.getCheckpointFile&lt;br&gt;
               res54: Option[String] = None&lt;br&gt;
               &lt;br&gt;
               b.collect&lt;br&gt;
               b.getCheckpointFile&lt;br&gt;
               res57: Option[String] =
               Some(file:/home/cloudera/Documents/cb978ffb-a346-4820-b3ba-d56580787b20/rdd-40)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;preferredLocations&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;preferredLocations&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&amp;nbsp; &lt;br&gt;
Returns the hosts which are preferred by this RDD. The actual
preference of a specific host depends on various assumptions.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;final def
   preferredLocations(split: Partition): Seq[String]
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;getStorageLevel&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;getStorageLevel&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&amp;nbsp; &lt;br&gt;
Retrieves the currently set storage level of the RDD. This can only be
used to assign a new storage level if the RDD does not have a storage
level set yet. The example below shows the error you will get, when you
try to reassign the storage level.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def getStorageLevel&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 65px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(1 to 100000, 2)&lt;br&gt;
               a.persist(org.apache.spark.storage.StorageLevel.DISK_ONLY)&lt;br&gt;
               a.getStorageLevel.description&lt;br&gt;
               String = Disk Serialized 1x Replicated&lt;br&gt;
               &lt;br&gt;
               a.cache&lt;br&gt;
               java.lang.UnsupportedOperationException: Cannot change storage level of
               an RDD after it was already assigned a level
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;br&gt;
&lt;a name=&quot;glom&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;glom&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&amp;nbsp; &lt;br&gt;
Assembles an array that contains all elements of the partition and
embeds it in an RDD. Each returned array contains the contents of one partition.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def glom(): RDD[Array[T]]&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 65px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(1 to 100, 3)&lt;br&gt;
               a.glom.collect&lt;br&gt;
               res8: Array[Array[Int]] = Array(Array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
               11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
               29, 30, 31, 32, 33), Array(34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44,
               45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
               63, 64, 65, 66), Array(67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78,
               79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96,
               97, 98, 99, 100))
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;a name=&quot;groupBy&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;groupBy&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&amp;nbsp; &lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def groupBy&lt;a href=&quot;f:%20T%0A%20%20%20=&amp;amp;gt;%20K&quot;&gt;K: ClassTag&lt;/a&gt;: RDD[(K, Iterable[T])]&lt;br&gt;
   def groupBy&lt;a href=&quot;f:%20T%20=&amp;amp;gt;%20K,%20numPartitions:%20Int&quot;&gt;K: ClassTag&lt;/a&gt;: RDD[(K,
   Iterable[T])]&lt;br&gt;
   def groupBy&lt;a href=&quot;f:%20T%20=&amp;amp;gt;%20K,%20p:%20Partitioner&quot;&gt;K: ClassTag&lt;/a&gt;: RDD[(K,
   Iterable[T])]
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 65px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(1 to 9, 3)&lt;br&gt;
               a.groupBy(x =&amp;gt; { if (x % 2 == 0) &amp;ldquo;even&amp;rdquo; else &amp;ldquo;odd&amp;rdquo; }).collect&lt;br&gt;
               res42: Array[(String, Seq[Int])] = Array((even,ArrayBuffer(2, 4, 6,
               8)), (odd,ArrayBuffer(1, 3, 5, 7, 9)))&lt;br&gt;
               &lt;br&gt;
               val a = sc.parallelize(1 to 9, 3)&lt;br&gt;
               def myfunc(a: Int) : Int =&lt;br&gt;
               {&lt;br&gt;
               &amp;nbsp; a % 2&lt;br&gt;
               }&lt;br&gt;
               a.groupBy(myfunc).collect&lt;br&gt;
               res3: Array[(Int, Seq[Int])] = Array((0,ArrayBuffer(2, 4, 6, 8)),
               (1,ArrayBuffer(1, 3, 5, 7, 9)))&lt;br&gt;
               &lt;br&gt;
               val a = sc.parallelize(1 to 9, 3)&lt;br&gt;
               def myfunc(a: Int) : Int =&lt;br&gt;
               {&lt;br&gt;
               &amp;nbsp; a % 2&lt;br&gt;
               }&lt;br&gt;
               a.groupBy(x =&amp;gt; myfunc(x), 3).collect&lt;br&gt;
               a.groupBy(myfunc(&lt;/em&gt;), 1).collect&lt;br&gt;
               res7: Array[(Int, Seq[Int])] = Array((0,ArrayBuffer(2, 4, 6, 8)),
               (1,ArrayBuffer(1, 3, 5, 7, 9)))&lt;br&gt;
               &lt;br&gt;
               import org.apache.spark.Partitioner&lt;br&gt;
               class MyPartitioner extends Partitioner {&lt;br&gt;
               def numPartitions: Int = 2&lt;br&gt;
               def getPartition(key: Any): Int =&lt;br&gt;
               {&lt;br&gt;
               &amp;nbsp;&amp;nbsp;&amp;nbsp; key match&lt;br&gt;
               &amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;
               &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; case null&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; =&amp;gt; 0&lt;br&gt;
               &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; case key: Int =&amp;gt;
               key&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; %
               numPartitions&lt;br&gt;
               &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; case
               &lt;em&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; =&amp;gt; key.hashCode %
               numPartitions&lt;br&gt;
               &amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;
               &amp;nbsp; }&lt;br&gt;
               &amp;nbsp; override def equals(other: Any): Boolean =&lt;br&gt;
               &amp;nbsp; {&lt;br&gt;
               &amp;nbsp;&amp;nbsp;&amp;nbsp; other match&lt;br&gt;
               &amp;nbsp;&amp;nbsp;&amp;nbsp; {&lt;br&gt;
               &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; case h: MyPartitioner =&amp;gt; true&lt;br&gt;
               &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; case
               _&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
               =&amp;gt; false&lt;br&gt;
               &amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br&gt;
               &amp;nbsp; }&lt;br&gt;
               }&lt;br&gt;
               val a = sc.parallelize(1 to 9, 3)&lt;br&gt;
               val p = new MyPartitioner()&lt;br&gt;
               val b = a.groupBy((x:Int) =&amp;gt; { x }, p)&lt;br&gt;
               val c = b.mapWith(i =&amp;gt; i)((a, b) =&amp;gt; (b, a))&lt;br&gt;
               c.collect&lt;br&gt;
               res42: Array[(Int, (Int, Seq[Int]))] = Array((0,(4,ArrayBuffer(4))),
               (0,(2,ArrayBuffer(2))), (0,(6,ArrayBuffer(6))), (0,(8,ArrayBuffer(8))),
               (1,(9,ArrayBuffer(9))), (1,(3,ArrayBuffer(3))), (1,(1,ArrayBuffer(1))),
               (1,(7,ArrayBuffer(7))), (1,(5,ArrayBuffer(5))))&lt;br&gt;
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;a name=&quot;groupByKey&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;groupByKey &lt;small&gt;[Pair]&lt;/small&gt;&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&amp;nbsp; &lt;br&gt;
Very similar to &lt;span style=&quot;font-style: italic;&quot;&gt;groupBy&lt;/span&gt;, but
instead of supplying a function, the key-component of each pair will
automatically be presented to the partitioner.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def groupByKey(): RDD[(K,
   Iterable[V])]&lt;br&gt;
   def groupByKey(numPartitions: Int): RDD[(K, Iterable[V])]&lt;br&gt;
   def groupByKey(partitioner: Partitioner): RDD[(K, Iterable[V])]
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 65px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(List(&amp;ldquo;dog&amp;rdquo;, &amp;ldquo;tiger&amp;rdquo;, &amp;ldquo;lion&amp;rdquo;, &amp;ldquo;cat&amp;rdquo;, &amp;ldquo;spider&amp;rdquo;,
               &amp;ldquo;eagle&amp;rdquo;), 2)&lt;br&gt;
               val b = a.keyBy(&lt;/em&gt;.length)&lt;br&gt;
               b.groupByKey.collect&lt;br&gt;
               res11: Array[(Int, Seq[String])] = Array((4,ArrayBuffer(lion)),
               (6,ArrayBuffer(spider)), (3,ArrayBuffer(dog, cat)),
               (5,ArrayBuffer(tiger, eagle)))
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;histogram&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;histogram &lt;small&gt;[Double]&lt;/small&gt;&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&amp;nbsp; &lt;br&gt;
These functions take an RDD of doubles and create a histogram with
either even spacing (the number of buckets equals to &lt;span style=&quot;font-style: italic;&quot;&gt;bucketCount&lt;/span&gt;)
or arbitrary spacing based on&amp;nbsp; custom bucket boundaries supplied
by the user via an array of double values. The result type of both
variants is slightly different, the first function will return a tuple
consisting of two arrays. The first array contains the computed bucket
boundary values and the second array contains the corresponding count
of values &lt;span style=&quot;font-style: italic;&quot;&gt;(i.e. the histogram)&lt;/span&gt;.
The second variant of the function will just return the histogram as an
array of integers.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def histogram(bucketCount: Int):
   Pair[Array[Double], Array[Long]]&lt;br&gt;
   def histogram(buckets: Array[Double], evenBuckets: Boolean = false):
   Array[Long]
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example with even spacing&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 65px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(List(1.1, 1.2, 1.3, 2.0, 2.1, 7.4, 7.5, 7.6, 8.8,
               9.0), 3)&lt;br&gt;
               a.histogram(5)&lt;br&gt;
               res11: (Array[Double], Array[Long]) = (Array(1.1, 2.68, 4.26, 5.84,
               7.42, 9.0),Array(5, 0, 0, 1, 4))&lt;br&gt;
               &lt;br&gt;
               val a = sc.parallelize(List(9.1, 1.0, 1.2, 2.1, 1.3, 5.0, 2.0, 2.1,
               7.4, 7.5, 7.6, 8.8, 10.0, 8.9, 5.5), 3)&lt;br&gt;
               a.histogram(6)&lt;br&gt;
               res18: (Array[Double], Array[Long]) = (Array(1.0, 2.5, 4.0, 5.5, 7.0,
               8.5, 10.0),Array(6, 0, 1, 1, 3, 4))
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example with custom spacing&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 65px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(List(1.1, 1.2, 1.3, 2.0, 2.1, 7.4, 7.5, 7.6, 8.8,
               9.0), 3)&lt;br&gt;
               a.histogram(Array(0.0, 3.0, 8.0))&lt;br&gt;
               res14: Array[Long] = Array(5, 3)&lt;br&gt;
               &lt;br&gt;
               val a = sc.parallelize(List(9.1, 1.0, 1.2, 2.1, 1.3, 5.0, 2.0, 2.1,
               7.4, 7.5, 7.6, 8.8, 10.0, 8.9, 5.5), 3)&lt;br&gt;
               a.histogram(Array(0.0, 5.0, 10.0))&lt;br&gt;
               res1: Array[Long] = Array(6, 9)&lt;br&gt;
               &lt;br&gt;
               a.histogram(Array(0.0, 5.0, 10.0, 15.0))&lt;br&gt;
               res1: Array[Long] = Array(6, 8, 1)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;id&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;id&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Retrieves the ID which has been assigned to the RDD by its device
context.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;val id: Int&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               y = sc.parallelize(1 to 10, 10)&lt;br&gt;
               y.id&lt;br&gt;
               res16: Int = 19
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;a name=&quot;intersection&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;intersection&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Returns the elements in the two RDDs which are the same.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def intersection(other: RDD[T],
   numPartitions: Int): RDD[T]&lt;br&gt;
   def intersection(other: RDD[T], partitioner: Partitioner)(implicit ord:
   Ordering[T] = null): RDD[T]&lt;br&gt;
   def intersection(other: RDD[T]): RDD[T]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;table style=&quot;text-align: left; width: 611px; height: 28px; margin-left: 40px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
   &lt;tbody&gt;
      &lt;tr&gt;
         &lt;td style=&quot;vertical-align: top;&quot;&gt;val x = sc.parallelize(1
            to 20)&lt;br&gt;
            val y = sc.parallelize(10 to 30)&lt;br&gt;
            val z = x.intersection(y)&lt;br&gt;
            &lt;br&gt;
            z.collect&lt;br&gt;
            res74: Array[Int] = Array(16, 12, 20, 13, 17, 14, 18, 10, 19, 15, 11)&lt;br&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
   &lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;isCheckpointed&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;isCheckpointed&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Indicates whether the RDD has been checkpointed. The flag will only
raise once the checkpoint has really been created.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def isCheckpointed: Boolean&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;sc.setCheckpointDir(&amp;ldquo;/home/cloudera/Documents&amp;rdquo;)&lt;br&gt;
               c.isCheckpointed&lt;br&gt;
               res6: Boolean = false&lt;br&gt;
               &lt;br&gt;
               c.checkpoint&lt;br&gt;
               c.isCheckpointed&lt;br&gt;
               res8: Boolean = false&lt;br&gt;
               &lt;br&gt;
               c.collect&lt;br&gt;
               c.isCheckpointed&lt;br&gt;
               res9: Boolean = true
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;iterator&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;iterator&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Returns a compatible iterator object for a partition of this RDD. This
function should never be called directly.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;final def iterator(split:
   Partition, context: TaskContext): Iterator[T]&lt;br&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;a name=&quot;join&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;join&lt;small&gt;
[Pair]&lt;/small&gt;&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Performs an inner join using two key-value RDDs. Please note that the
keys must be generally comparable to make this work.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def join&lt;a href=&quot;other:%20RDD%5B(K,%20W)%5D&quot;&gt;W&lt;/a&gt;:
   RDD[(K, (V, W))]&lt;br&gt;
   def join&lt;a href=&quot;other:%20RDD%5B(K,%20W)%5D,%20numPartitions:%20Int&quot;&gt;W&lt;/a&gt;: RDD[(K, (V, W))]&lt;br&gt;
   def join&lt;a href=&quot;other:%20RDD%5B(K,%20W)%5D,%20partitioner:%20Partitioner&quot;&gt;W&lt;/a&gt;: RDD[(K, (V,
   W))]&lt;br&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;/span&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 639px; height: 159px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(List(&amp;ldquo;dog&amp;rdquo;, &amp;ldquo;salmon&amp;rdquo;, &amp;ldquo;salmon&amp;rdquo;, &amp;ldquo;rat&amp;rdquo;, &amp;ldquo;elephant&amp;rdquo;),
               3)&lt;br&gt;
               val b = a.keyBy(&lt;em&gt;.length)&lt;br&gt;
               val c =
               sc.parallelize(List(&amp;ldquo;dog&amp;rdquo;,&amp;ldquo;cat&amp;rdquo;,&amp;ldquo;gnu&amp;rdquo;,&amp;ldquo;salmon&amp;rdquo;,&amp;ldquo;rabbit&amp;rdquo;,&amp;ldquo;turkey&amp;rdquo;,&amp;ldquo;wolf&amp;rdquo;,&amp;ldquo;bear&amp;rdquo;,&amp;ldquo;bee&amp;rdquo;),
               3)&lt;br&gt;
               val d = c.keyBy(&lt;/em&gt;.length)&lt;br&gt;
               b.join(d).collect&lt;br&gt;
               &lt;br&gt;res0:
               Array[(Int, (String, String))] = Array((6,(salmon,salmon)),
               (6,(salmon,rabbit)), (6,(salmon,turkey)), (6,(salmon,salmon)),
               (6,(salmon,rabbit)), (6,(salmon,turkey)), (3,(dog,dog)), (3,(dog,cat)),
               (3,(dog,gnu)), (3,(dog,bee)), (3,(rat,dog)), (3,(rat,cat)),
               (3,(rat,gnu)), (3,(rat,bee)))
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;keyBy&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;keyBy&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Constructs two-component tuples (key-value pairs) by applying a
function on each data item. The result of the function becomes the key
and the original data item becomes the value of the newly created
tuples.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def keyBy&lt;a href=&quot;f:%20T%20=&amp;amp;gt;%20K&quot;&gt;K&lt;/a&gt;:
   RDD[(K, T)]&lt;br&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;/span&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(List(&amp;ldquo;dog&amp;rdquo;, &amp;ldquo;salmon&amp;rdquo;, &amp;ldquo;salmon&amp;rdquo;, &amp;ldquo;rat&amp;rdquo;, &amp;ldquo;elephant&amp;rdquo;),
               3)&lt;br&gt;
               val b = a.keyBy(&lt;em&gt;.length)&lt;br&gt;
               b.collect&lt;br&gt;
               res26: Array[(Int, String)] = Array((3,dog), (6,salmon), (6,salmon),
               (3,rat), (8,elephant))
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;keys&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;keys &lt;small&gt;[Pair]&lt;/small&gt;&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;Extracts the keys from all contained tuples and returns
them in a new RDD.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def keys: RDD[K]&lt;br&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;/span&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(List(&amp;ldquo;dog&amp;rdquo;, &amp;ldquo;tiger&amp;rdquo;, &amp;ldquo;lion&amp;rdquo;, &amp;ldquo;cat&amp;rdquo;, &amp;ldquo;panther&amp;rdquo;,
               &amp;ldquo;eagle&amp;rdquo;), 2)&lt;br&gt;
               val b = a.map(x =&amp;gt; (x.length, x))&lt;br&gt;
               b.keys.collect&lt;br&gt;
               res2: Array[Int] = Array(3, 5, 4, 3, 7, 5)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;leftOuterJoin&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;leftOuterJoin &lt;small&gt;[Pair]&lt;/small&gt;&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Performs an left outer join using two key-value RDDs. Please note that
the keys must be generally comparable to make this work correctly.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def leftOuterJoin&lt;a href=&quot;other:%0A%20%20%20RDD%5B(K,%20W)%5D&quot;&gt;W&lt;/a&gt;: RDD[(K, (V, Option[W]))]&lt;br&gt;
   def leftOuterJoin&lt;a href=&quot;other:%20RDD%5B(K,%20W)%5D,%20numPartitions:%20Int&quot;&gt;W&lt;/a&gt;: RDD[(K,
   (V, Option[W]))]&lt;br&gt;
   def leftOuterJoin&lt;a href=&quot;other:%20RDD%5B(K,%20W)%5D,%20partitioner:%20Partitioner&quot;&gt;W&lt;/a&gt;:
   RDD[(K, (V, Option[W]))]&lt;br&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;/span&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(List(&amp;ldquo;dog&amp;rdquo;, &amp;ldquo;salmon&amp;rdquo;, &amp;ldquo;salmon&amp;rdquo;, &amp;ldquo;rat&amp;rdquo;, &amp;ldquo;elephant&amp;rdquo;),
               3)&lt;br&gt;
               val b = a.keyBy(&lt;/em&gt;.length)&lt;br&gt;
               val c =
               sc.parallelize(List(&amp;ldquo;dog&amp;rdquo;,&amp;ldquo;cat&amp;rdquo;,&amp;ldquo;gnu&amp;rdquo;,&amp;ldquo;salmon&amp;rdquo;,&amp;ldquo;rabbit&amp;rdquo;,&amp;ldquo;turkey&amp;rdquo;,&amp;ldquo;wolf&amp;rdquo;,&amp;ldquo;bear&amp;rdquo;,&amp;ldquo;bee&amp;rdquo;),
               3)&lt;br&gt;
               val d = c.keyBy(&lt;em&gt;.length)&lt;br&gt;
               b.leftOuterJoin(d).collect&lt;br&gt;
               &lt;br&gt;
               res1: Array[(Int, (String, Option[String]))] =
               Array((6,(salmon,Some(salmon))), (6,(salmon,Some(rabbit))),
               (6,(salmon,Some(turkey))), (6,(salmon,Some(salmon))),
               (6,(salmon,Some(rabbit))), (6,(salmon,Some(turkey))),
               (3,(dog,Some(dog))), (3,(dog,Some(cat))), (3,(dog,Some(gnu))),
               (3,(dog,Some(bee))), (3,(rat,Some(dog))), (3,(rat,Some(cat))),
               (3,(rat,Some(gnu))), (3,(rat,Some(bee))), (8,(elephant,None)))
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;lookup&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;lookup&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Scans the RDD for all keys that match the provided value and returns
their values as a Scala sequence.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def lookup(key: K): Seq[V]&lt;br&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;/span&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(List(&amp;ldquo;dog&amp;rdquo;, &amp;ldquo;tiger&amp;rdquo;, &amp;ldquo;lion&amp;rdquo;, &amp;ldquo;cat&amp;rdquo;, &amp;ldquo;panther&amp;rdquo;,
               &amp;ldquo;eagle&amp;rdquo;), 2)&lt;br&gt;
               val b = a.map(x =&amp;gt; (x.length, x))&lt;br&gt;
               b.lookup(5)&lt;br&gt;
               res0: Seq[String] = WrappedArray(tiger, eagle)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;map&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;map&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Applies a transformation function on each item of the RDD and returns
the result as a new RDD.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def map&lt;a href=&quot;f:%20T%20=&amp;amp;gt;%0A%20%20%20U&quot;&gt;U: ClassTag&lt;/a&gt;: RDD[U]&lt;br&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;/span&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(List(&amp;ldquo;dog&amp;rdquo;, &amp;ldquo;salmon&amp;rdquo;, &amp;ldquo;salmon&amp;rdquo;, &amp;ldquo;rat&amp;rdquo;, &amp;ldquo;elephant&amp;rdquo;),
               3)&lt;br&gt;
               val b = a.map(&lt;/em&gt;.length)&lt;br&gt;
               val c = a.zip(b)&lt;br&gt;
               c.collect&lt;br&gt;
               res0: Array[(String, Int)] = Array((dog,3), (salmon,6), (salmon,6),
               (rat,3), (elephant,8))
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;mapPartitions&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;mapPartitions&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
This is a specialized map that is called only once for each partition.
The entire content of the respective partitions is available as a
sequential stream of values via the input argument (&lt;span style=&quot;font-style: italic;&quot;&gt;Iterarator[T]&lt;/span&gt;). The custom function
must return yet another &lt;span style=&quot;font-style: italic;&quot;&gt;Iterator[U]&lt;/span&gt;.
The combined result iterators are automatically converted into a new
RDD. Please note, that the tuples (3,4) and (6,7) are missing from the
following result due to the partitioning we chose.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def mapPartitions&lt;a href=&quot;f:%0A%20%20%20Iterator%5BT%5D%20=&amp;amp;gt;%20Iterator%5BU%5D,%20preservesPartitioning:%20Boolean%20=%20false&quot;&gt;U: ClassTag&lt;/a&gt;:
   RDD[U]&lt;br&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;/span&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;Example 1&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(1 to 9, 3)&lt;br&gt;
               def myfunc&lt;a href=&quot;iter:%20Iterator%5BT%5D&quot;&gt;T&lt;/a&gt; : Iterator[(T, T)] = {&lt;br&gt;
               &amp;nbsp; var res = List&lt;a href=&quot;&quot;&gt;(T, T)&lt;/a&gt;&lt;br&gt;
               &amp;nbsp; var pre = iter.next&lt;br&gt;
               &amp;nbsp; while (iter.hasNext)&lt;br&gt;
               &amp;nbsp; {&lt;br&gt;
               &amp;nbsp;&amp;nbsp;&amp;nbsp; val cur = iter.next;&lt;br&gt;
               &amp;nbsp;&amp;nbsp;&amp;nbsp; res .::= (pre, cur)&lt;br&gt;
               &amp;nbsp;&amp;nbsp;&amp;nbsp; pre = cur;&lt;br&gt;
               &amp;nbsp; }&lt;br&gt;
               &amp;nbsp; res.iterator&lt;br&gt;
               }&lt;br&gt;
               a.mapPartitions(myfunc).collect&lt;br&gt;
               res0: Array[(Int, Int)] = Array((2,3), (1,2), (5,6), (4,5), (8,9),
               (7,8))
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example 2&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               x = sc.parallelize(List(1, 2, 3, 4, 5, 6, 7, 8, 9,10),
               3)&lt;br&gt;
               def myfunc(iter: Iterator[Int]) : Iterator[Int] = {&lt;br&gt;
               &amp;nbsp; var res = List&lt;a href=&quot;&quot;&gt;Int&lt;/a&gt;&lt;br&gt;
               &amp;nbsp; while (iter.hasNext) {&lt;br&gt;
               &amp;nbsp;&amp;nbsp;&amp;nbsp; val cur = iter.next;&lt;br&gt;
               &amp;nbsp;&amp;nbsp;&amp;nbsp; res = res :::
               List.fill(scala.util.Random.nextInt(10))(cur)&lt;br&gt;
               &amp;nbsp; }&lt;br&gt;
               &amp;nbsp; res.iterator&lt;br&gt;
               }&lt;br&gt;
               x.mapPartitions(myfunc).collect&lt;br&gt;
               // some of the number are not outputted at all. This is because the
               random number generated for it is zero.&lt;br&gt;
               res8: Array[Int] = Array(1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4,
               4, 4, 4, 4, 4, 4, 5, 7, 7, 7, 9, 9, 10)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
The above program can also be written using &lt;span style=&quot;font-weight: bold;&quot;&gt;flatMap&lt;/span&gt; as follows.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example 2 using flatmap&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               x&amp;nbsp; = sc.parallelize(1 to 10, 3)&lt;br&gt;
               x.flatMap(List.fill(scala.util.Random.nextInt(10))(&lt;em&gt;)).collect&lt;br&gt;
               &lt;br&gt;
               res1: Array[Int] = Array(1, 2, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5,
               5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9,
               9, 10, 10, 10, 10, 10, 10, 10, 10)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;mapPartitionsWithContext&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;mapPartitionsWithContext&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;font-weight: bold;&quot;&gt; (deprecated and developer API)&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
Similar to &lt;span style=&quot;font-style: italic;&quot;&gt;mapPartitions&lt;/span&gt;, but
allows accessing information about the processing state within the
mapper.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def mapPartitionsWithContext&lt;a href=&quot;f:%20(TaskContext,%20Iterator%5BT%5D)%20=&amp;amp;gt;%20Iterator%5BU%5D,%0A%20%20%20preservesPartitioning:%20Boolean%20=%20false&quot;&gt;U:
   ClassTag&lt;/a&gt;: RDD[U]&lt;br&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;/span&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(1 to 9, 3)&lt;br&gt;
               import org.apache.spark.TaskContext&lt;br&gt;
               def myfunc(tc: TaskContext, iter: Iterator[Int]) : Iterator[Int] = {&lt;br&gt;
               &amp;nbsp; tc.addOnCompleteCallback(() =&amp;gt; println(&lt;br&gt;
               &amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;ldquo;Partition: &amp;rdquo;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; +
               tc.partitionId +&lt;br&gt;
               &amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;ldquo;, AttemptID: &amp;rdquo;&amp;nbsp;&amp;nbsp; +
               tc.attemptId ))&lt;br&gt;
               &amp;nbsp; &lt;br&gt;
               &amp;nbsp; iter.toList.filter(&lt;/em&gt; % 2 == 0).iterator&lt;br&gt;
               }&lt;br&gt;
               a.mapPartitionsWithContext(myfunc).collect&lt;br&gt;
               &lt;br&gt;
               14/04/01 23:05:48 INFO SparkContext: Starting job: collect at
               &amp;lt;console&amp;gt;:20&lt;br&gt;
               &amp;hellip;&lt;br&gt;
               14/04/01 23:05:48 INFO Executor: Running task ID 0&lt;br&gt;
               Partition: 0, AttemptID: 0, Interrupted: false&lt;br&gt;
               &amp;hellip;&lt;br&gt;
               14/04/01 23:05:48 INFO Executor: Running task ID 1&lt;br&gt;
               14/04/01 23:05:48 INFO TaskSetManager: Finished TID 0 in 470 ms on
               localhost (progress: 0/3)&lt;br&gt;
               &amp;hellip;&lt;br&gt;
               14/04/01 23:05:48 INFO Executor: Running task ID 2&lt;br&gt;
               14/04/01 23:05:48 INFO TaskSetManager: Finished TID 1 in 23 ms on
               localhost (progress: 1/3)&lt;br&gt;
               14/04/01 23:05:48 INFO DAGScheduler: Completed ResultTask(0, 1)&lt;br&gt;
               &lt;br&gt;
               ?&lt;br&gt;
               res0: Array[Int] = Array(2, 6, 4, 8)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;mapPartitionsWithIndex&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;mapPartitionsWithIndex&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Similar to &lt;span style=&quot;font-style: italic;&quot;&gt;mapPartitions&lt;/span&gt;, but
takes two parameters. The first parameter is the index of the partition
and the second is an iterator through all the items within this
partition. The output is an iterator containing the list of items after
applying whatever transformation the function encodes.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def mapPartitionsWithIndex&lt;a href=&quot;f:%20(Int,%20Iterator%5BT%5D)%20=&amp;amp;gt;%20Iterator%5BU%5D,%0A%20%20%20preservesPartitioning:%20Boolean%20=%20false&quot;&gt;U:
   ClassTag&lt;/a&gt;: RDD[U]&lt;br&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;/span&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;/span&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               x = sc.parallelize(List(1,2,3,4,5,6,7,8,9,10), 3)&lt;br&gt;
               def myfunc(index: Int, iter: Iterator[Int]) : Iterator[String] = {&lt;br&gt;
               &amp;nbsp; iter.toList.map(x =&amp;gt; index + &amp;ldquo;,&amp;rdquo; + x).iterator&lt;br&gt;
               }&lt;br&gt;
               x.mapPartitionsWithIndex(myfunc).collect()&lt;br&gt;
               res10: Array[String] = Array(0,1, 0,2, 0,3, 1,4, 1,5, 1,6, 2,7, 2,8,
               2,9, 2,10)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;mapPartitionsWithSplit&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;mapPartitionsWithSplit&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
This method has been marked as deprecated in the API. So, you should
not use this method anymore. Deprecated methods will not be covered in
this document.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def mapPartitionsWithSplit&lt;a href=&quot;f:%20(Int,%20Iterator%5BT%5D)%20=&amp;amp;gt;%20Iterator%5BU%5D,%0A%20%20%20preservesPartitioning:%20Boolean%20=%20false&quot;&gt;U:
   ClassTag&lt;/a&gt;: RDD[U]&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
   &lt;br&gt;
   &lt;br&gt;
   &lt;/span&gt; 
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt; &lt;/span&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;a name=&quot;mapValues&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;mapValues &lt;small&gt;[Pair]&lt;/small&gt;&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Takes the values of a RDD that consists of two-component tuples, and
applies the provided function to transform each value. Then, it forms
new two-component tuples using the key and the transformed value and
stores them in a new RDD.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def mapValues&lt;a href=&quot;f:%20V%20=&amp;amp;gt;%20U&quot;&gt;U&lt;/a&gt;:
   RDD[(K, U)]&lt;br&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;/span&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;/span&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(List(&amp;ldquo;dog&amp;rdquo;, &amp;ldquo;tiger&amp;rdquo;, &amp;ldquo;lion&amp;rdquo;, &amp;ldquo;cat&amp;rdquo;, &amp;ldquo;panther&amp;rdquo;,
               &amp;ldquo;eagle&amp;rdquo;), 2)&lt;br&gt;
               val b = a.map(x =&amp;gt; (x.length, x))&lt;br&gt;
               b.mapValues(&amp;ldquo;x&amp;rdquo; + _ + &amp;ldquo;x&amp;rdquo;).collect&lt;br&gt;
               res5: Array[(Int, String)] = Array((3,xdogx), (5,xtigerx), (4,xlionx),
               (3,xcatx), (7,xpantherx), (5,xeaglex))
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;mapWith&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;mapWith&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&amp;nbsp;
&lt;span style=&quot;font-weight: bold;&quot;&gt;(deprecated)&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
This is an extended version of &lt;span style=&quot;font-style: italic;&quot;&gt;map&lt;/span&gt;.
It takes two function arguments. The first argument must conform to &lt;span style=&quot;font-style: italic;&quot;&gt;Int -&amp;gt; T&lt;/span&gt; and is executed once
per partition. It will map the partition index to some transformed
partition index of type &lt;span style=&quot;font-style: italic;&quot;&gt;T&lt;/span&gt;.
This is where it is nice to do some kind of initialization code once
per partition. Like create a Random number generator object.
The second function must conform to &lt;span style=&quot;font-style: italic;&quot;&gt;(U,
T) -&amp;gt; U&lt;/span&gt;. &lt;span style=&quot;font-style: italic;&quot;&gt;T&lt;/span&gt; is the
transformed partition index and &lt;span style=&quot;font-style: italic;&quot;&gt;U&lt;/span&gt;
is a data item of the RDD. Finally the function has to return a
transformed data item of type &lt;span style=&quot;font-style: italic;&quot;&gt;U&lt;/span&gt;.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def mapWith&lt;a href=&quot;constructA:%20Int%20=&amp;amp;gt;%20A,%20preservesPartitioning:%20Boolean%20=%0A%20%20%20false&quot;&gt;A: ClassTag, U:
   ClassTag&lt;/a&gt;(f: (T, A) =&amp;gt; U): RDD[U]&lt;br&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;/span&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;/span&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;//
               generates 9 random numbers less than 1000. &lt;br&gt;
               val x = sc.parallelize(1 to 9, 3)&lt;br&gt;
               x.mapWith(a =&amp;gt; new scala.util.Random)((x, r) =&amp;gt;
               r.nextInt(1000)).collect&lt;br&gt;
               res0: Array[Int] = Array(940, 51, 779, 742, 757, 982, 35, 800, 15)&lt;br&gt;
               &lt;br&gt;
               val a = sc.parallelize(1 to 9, 3)&lt;br&gt;
               val b = a.mapWith(&amp;ldquo;Index:&amp;rdquo; + &lt;em&gt;)((a, b) =&amp;gt; (&amp;ldquo;Value:&amp;rdquo; + a, b))&lt;br&gt;
               b.collect&lt;br&gt;
               res0: Array[(String, String)] = Array((Value:1,Index:0),
               (Value:2,Index:0), (Value:3,Index:0), (Value:4,Index:1),
               (Value:5,Index:1), (Value:6,Index:1), (Value:7,Index:2),
               (Value:8,Index:2), (Value:9,Index:2)&lt;br&gt;
               &lt;br&gt;
               &lt;br&gt;
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;max&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;max&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
Returns the largest element in the RDD&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def max()(implicit ord:
   Ordering[T]): T&lt;br&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;/span&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;/span&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;table style=&quot;text-align: left; width: 630px; height: 28px; margin-left: 40px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
   &lt;tbody&gt;
      &lt;tr&gt;
         &lt;td style=&quot;vertical-align: top;&quot;&gt;val y = sc.parallelize(10
            to 30)&lt;br&gt;
            y.max&lt;br&gt;
            res75: Int = 30&lt;br&gt;
            &lt;br&gt;
            val a = sc.parallelize(List((10, &amp;ldquo;dog&amp;rdquo;), (3, &amp;ldquo;tiger&amp;rdquo;), (9, &amp;ldquo;lion&amp;rdquo;), (18, &amp;ldquo;cat&amp;rdquo;)))&lt;br&gt;
            a.max&lt;br&gt;
            res6: (Int, String) = (18,cat)&lt;br&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
   &lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;mean&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;mean &lt;small&gt;[Double]&lt;/small&gt;,
meanApprox &lt;small&gt;[Double]&lt;/small&gt;&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Calls &lt;span style=&quot;font-style: italic;&quot;&gt;stats&lt;/span&gt; and extracts the
mean component. The approximate version of the function can finish
somewhat faster in some scenarios. However, it trades accuracy for
speed.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def mean(): Double&lt;br&gt;
   def meanApprox(timeout: Long, confidence: Double = 0.95):
   PartialResult[BoundedDouble]&lt;br&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;/span&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;/span&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(List(9.1, 1.0, 1.2, 2.1, 1.3, 5.0, 2.0, 2.1, 7.4,
               7.5, 7.6, 8.8, 10.0, 8.9, 5.5), 3)&lt;br&gt;
               a.mean&lt;br&gt;
               res0: Double = 5.3
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;a name=&quot;min&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;min&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Returns the smallest element in the RDD&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def min()(implicit ord:
   Ordering[T]): T&lt;br&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;/span&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;/span&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;table style=&quot;text-align: left; width: 637px; height: 28px; margin-left: 40px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
   &lt;tbody&gt;
      &lt;tr&gt;
         &lt;td style=&quot;vertical-align: top;&quot;&gt;val y = sc.parallelize(10
            to 30)&lt;br&gt;
            y.min&lt;br&gt;
            res75: Int = 10&lt;br&gt;
            &lt;br&gt;
            &lt;br&gt;
            val a = sc.parallelize(List((10, &amp;ldquo;dog&amp;rdquo;), (3, &amp;ldquo;tiger&amp;rdquo;), (9, &amp;ldquo;lion&amp;rdquo;), (8, &amp;ldquo;cat&amp;rdquo;)))&lt;br&gt;
            a.min&lt;br&gt;
            res4: (Int, String) = (3,tiger)&lt;br&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
   &lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;name&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;name, setName&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Allows a RDD to be tagged with a custom name.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;@transient var name: String&lt;br&gt;
   def setName(_name: String)&lt;br&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;/span&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;/span&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               y = sc.parallelize(1 to 10, 10)&lt;br&gt;
               y.name&lt;br&gt;
               res13: String = null&lt;br&gt;
               y.setName(&amp;ldquo;Fancy RDD Name&amp;rdquo;)&lt;br&gt;
               y.name&lt;br&gt;
               res15: String = Fancy RDD Name
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;partitionBy&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;partitionBy &lt;small&gt;[Pair]&lt;/small&gt;&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Repartitions as key-value RDD using its keys. The partitioner
implementation can be supplied as the first argument.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def partitionBy(partitioner:
   Partitioner): RDD[(K, V)]&lt;br&gt;
&lt;/div&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;a name=&quot;partitioner&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;partitioner &lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Specifies a function pointer to the default partitioner that will be
used for &lt;span style=&quot;font-style: italic;&quot;&gt;groupBy&lt;/span&gt;, &lt;span style=&quot;font-style: italic;&quot;&gt;subtract&lt;/span&gt;, &lt;span style=&quot;font-style: italic;&quot;&gt;reduceByKey&lt;/span&gt; (from &lt;span style=&quot;font-style: italic;&quot;&gt;PairedRDDFunctions&lt;/span&gt;), etc. functions.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;@transient val partitioner:
   Option[Partitioner]
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;partitions&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;partitions &lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Returns an array of the partition objects associated with this RDD.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;final def partitions:
   Array[Partition]
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               b = sc.parallelize(List(&amp;ldquo;Gnu&amp;rdquo;, &amp;ldquo;Cat&amp;rdquo;, &amp;ldquo;Rat&amp;rdquo;, &amp;ldquo;Dog&amp;rdquo;, &amp;ldquo;Gnu&amp;rdquo;, &amp;ldquo;Rat&amp;rdquo;), 2)&lt;br&gt;
               b.partitions&lt;br&gt;
               res48: Array[org.apache.spark.Partition] =
               Array(org.apache.spark.rdd.ParallelCollectionPartition@18aa,
               org.apache.spark.rdd.ParallelCollectionPartition@18ab)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;persist&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;persist, cache &lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
These functions can be used to adjust the storage level of a RDD. When
freeing up memory, Spark will use the storage level identifier to
decide which partitions should be kept. The parameterless variants &lt;span style=&quot;font-style: italic;&quot;&gt;persist()&lt;/span&gt; and &lt;span style=&quot;font-style: italic;&quot;&gt;cache()&lt;/span&gt; are just abbreviations for &lt;span style=&quot;font-style: italic;&quot;&gt;persist(StorageLevel.MEMORY_ONLY)&lt;/span&gt;. &lt;span style=&quot;font-style: italic;&quot;&gt;(Warning: Once the storage level has been
changed, it cannot be changed again!)&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def cache(): RDD[T]&lt;br&gt;
   def persist(): RDD[T]&lt;br&gt;
   def persist(newLevel: StorageLevel): RDD[T]
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               c = sc.parallelize(List(&amp;ldquo;Gnu&amp;rdquo;, &amp;ldquo;Cat&amp;rdquo;, &amp;ldquo;Rat&amp;rdquo;, &amp;ldquo;Dog&amp;rdquo;, &amp;ldquo;Gnu&amp;rdquo;, &amp;ldquo;Rat&amp;rdquo;), 2)&lt;br&gt;
               c.getStorageLevel&lt;br&gt;
               res0: org.apache.spark.storage.StorageLevel = StorageLevel(false,
               false, false, false, 1)&lt;br&gt;
               c.cache&lt;br&gt;
               c.getStorageLevel&lt;br&gt;
               res2: org.apache.spark.storage.StorageLevel = StorageLevel(false, true,
               false, true, 1)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;pipe&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;pipe &lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Takes the RDD data of each partition and sends it via stdin to a
shell-command. The resulting output of the command is captured and
returned as a RDD of string values.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def pipe(command: String):
   RDD[String]&lt;br&gt;
   def pipe(command: String, env: Map[String, String]): RDD[String]&lt;br&gt;
   def pipe(command: Seq[String], env: Map[String, String] = Map(),
   printPipeContext: (String =&amp;gt; Unit) =&amp;gt; Unit = null,
   printRDDElement: (T, String =&amp;gt; Unit) =&amp;gt; Unit = null): RDD[String]
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(1 to 9, 3)&lt;br&gt;
               a.pipe(&amp;ldquo;head -n 1&amp;rdquo;).collect&lt;br&gt;
               res2: Array[String] = Array(1, 4, 7)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt; &lt;a name=&quot;randomSplit&quot;&gt;&lt;/a&gt;&lt;br&gt;
randomSplit &lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Randomly splits an RDD into multiple smaller RDDs according to a
weights Array which specifies the percentage of the total data elements
that is assigned to each smaller RDD. Note the actual size of each
smaller RDD is only approximately equal to the percentages specified by
the weights Array. The second example below shows the number of items
in each smaller RDD does not exactly match the weights Array. &amp;nbsp; A
random optional seed can be specified. This function is useful for
spliting data into a training set and a testing set for machine
learning.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def randomSplit(weights:
   Array[Double], seed: Long = Utils.random.nextLong): Array[RDD[T]]
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;
&lt;table style=&quot;text-align: left; width: 602px; height: 28px; margin-left: 40px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
   &lt;tbody&gt;
      &lt;tr&gt;
         &lt;td style=&quot;vertical-align: top;&quot;&gt;val y = sc.parallelize(1
            to 10)&lt;br&gt;
            val splits = y.randomSplit(Array(0.6, 0.4), seed = 11L)&lt;br&gt;
            val training = splits(0)&lt;br&gt;
            val test = splits(1)&lt;br&gt;
            training.collect&lt;br&gt;
            res:85 Array[Int] = Array(1, 4, 5, 6, 8, 10)&lt;br&gt;
            test.collect&lt;br&gt;
            res86: Array[Int] = Array(2, 3, 7, 9)&lt;br&gt;
            &lt;br&gt;
            val y = sc.parallelize(1 to 10)&lt;br&gt;
            val splits = y.randomSplit(Array(0.1, 0.3, 0.6))&lt;br&gt;
            &lt;br&gt;
            val rdd1 = splits(0)&lt;br&gt;
            val rdd2 = splits(1)&lt;br&gt;
            val rdd3 = splits(2)&lt;br&gt;
            &lt;br&gt;
            rdd1.collect&lt;br&gt;
            res87: Array[Int] = Array(4, 10)&lt;br&gt;
            rdd2.collect&lt;br&gt;
            res88: Array[Int] = Array(1, 3, 5, 8)&lt;br&gt;
            rdd3.collect&lt;br&gt;
            res91: Array[Int] = Array(2, 6, 7, 9)&lt;br&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
   &lt;/tbody&gt;
&lt;/table&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;a name=&quot;reduce&quot;&gt;&lt;/a&gt;&lt;br&gt;
reduce &lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
This function provides the well-known &lt;span style=&quot;font-style: italic;&quot;&gt;reduce&lt;/span&gt;
functionality in Spark. Please note that any function &lt;span style=&quot;font-style: italic;&quot;&gt;f&lt;/span&gt; you provide, should be
commutative in order to generate reproducible results.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def reduce(f: (T, T) =&amp;gt; T): T&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(1 to 100, 3)&lt;br&gt;
               a.reduce(&lt;/em&gt; + &lt;em&gt;)&lt;br&gt;
               res41: Int = 5050
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;reduceByKey&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;reduceByKey &lt;small&gt;[Pair]&lt;/small&gt;,&amp;nbsp;
reduceByKeyLocally &lt;small&gt;[Pair],&lt;/small&gt; reduceByKeyToDriver &lt;small&gt;[Pair]&lt;/small&gt;&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
This function provides the well-known &lt;span style=&quot;font-style: italic;&quot;&gt;reduce&lt;/span&gt;
functionality in Spark. Please note that any function &lt;span style=&quot;font-style: italic;&quot;&gt;f&lt;/span&gt; you provide, should be
commutative in order to generate reproducible results.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def reduceByKey(func: (V, V)
   =&amp;gt; V): RDD[(K, V)]&lt;br&gt;
   def reduceByKey(func: (V, V) =&amp;gt; V, numPartitions: Int): RDD[(K, V)]&lt;br&gt;
   def reduceByKey(partitioner: Partitioner, func: (V, V) =&amp;gt; V):
   RDD[(K, V)]&lt;br&gt;
   def reduceByKeyLocally(func: (V, V) =&amp;gt; V): Map[K, V]&lt;br&gt;
   def reduceByKeyToDriver(func: (V, V) =&amp;gt; V): Map[K, V]
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(List(&amp;ldquo;dog&amp;rdquo;, &amp;ldquo;cat&amp;rdquo;, &amp;ldquo;owl&amp;rdquo;, &amp;ldquo;gnu&amp;rdquo;, &amp;ldquo;ant&amp;rdquo;), 2)&lt;br&gt;
               val b = a.map(x =&amp;gt; (x.length, x))&lt;br&gt;
               b.reduceByKey(&lt;/em&gt; + &lt;em&gt;).collect&lt;br&gt;
               res86: Array[(Int, String)] = Array((3,dogcatowlgnuant))&lt;br&gt;
               &lt;br&gt;
               val a = sc.parallelize(List(&amp;ldquo;dog&amp;rdquo;, &amp;ldquo;tiger&amp;rdquo;, &amp;ldquo;lion&amp;rdquo;, &amp;ldquo;cat&amp;rdquo;, &amp;ldquo;panther&amp;rdquo;,
               &amp;ldquo;eagle&amp;rdquo;), 2)&lt;br&gt;
               val b = a.map(x =&amp;gt; (x.length, x))&lt;br&gt;
               b.reduceByKey(&lt;/em&gt; + &lt;em&gt;).collect&lt;br&gt;
               res87: Array[(Int, String)] = Array((4,lion), (3,dogcat), (7,panther),
               (5,tigereagle))
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;repartition&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;repartition&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
This function changes the number of partitions to the number specified by the numPartitions parameter  &lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def repartition(numPartitions: Int)(implicit ord: Ordering[T] = null): RDD[T]&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;table style=&quot;text-align: left; width: 631px; height: 24px; margin-left: 40px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
   &lt;tbody&gt;
      &lt;tr&gt;
         &lt;td style=&quot;vertical-align: top;&quot;&gt;val rdd = sc.parallelize(List(1, 2, 10, 4, 5, 2, 1, 1, 1), 3)&lt;br&gt;
            rdd.partitions.length&lt;br&gt;
            res2: Int = 3&lt;br&gt;
            val rdd2&amp;nbsp; = rdd.repartition(5)&lt;br&gt;
            rdd2.partitions.length&lt;br&gt;
            res6: Int = 5&lt;br&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
   &lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;repartitionAndSortWithinPartitions&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;repartitionAndSortWithinPartitions&lt;/span&gt;&lt;/big&gt;&lt;/big&gt; [Ordered]&lt;br&gt;
&lt;br&gt;
Repartition the RDD according to the given partitioner and, within each resulting partition, sort records by their keys.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def repartitionAndSortWithinPartitions(partitioner: Partitioner): RDD[(K, V)]&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;table style=&quot;text-align: left; width: 683px; margin-left: 40px; height: 23px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
   &lt;tbody&gt;
      &lt;tr&gt;
         &lt;td style=&quot;vertical-align: top;&quot;&gt;// first we will do range partitioning which is not sorted&lt;br&gt;
            val randRDD = sc.parallelize(List( (2,&amp;ldquo;cat&amp;rdquo;), (6, &amp;ldquo;mouse&amp;rdquo;),(7, &amp;ldquo;cup&amp;rdquo;), (3, &amp;ldquo;book&amp;rdquo;), (4, &amp;ldquo;tv&amp;rdquo;), (1, &amp;ldquo;screen&amp;rdquo;), (5, &amp;ldquo;heater&amp;rdquo;)), 3)&lt;br&gt;
            val rPartitioner = new org.apache.spark.RangePartitioner(3, randRDD)&lt;br&gt;
            val partitioned = randRDD.partitionBy(rPartitioner)&lt;br&gt;
            def myfunc(index: Int, iter: Iterator[(Int, String)]) : Iterator[String] = {&lt;br&gt;
            &amp;nbsp; iter.toList.map(x =&amp;gt; &amp;ldquo;[partID:&amp;rdquo; +&amp;nbsp; index + &amp;ldquo;, val: &amp;rdquo; + x + &amp;ldquo;]&amp;rdquo;).iterator&lt;br&gt;
            }&lt;br&gt;
            partitioned.mapPartitionsWithIndex(myfunc).collect&lt;br&gt;
            &lt;br&gt;
            res0: Array[String] = Array([partID:0, val: (2,cat)], [partID:0, val:
            (3,book)], [partID:0, val: (1,screen)], [partID:1, val: (4,tv)],
            [partID:1, val: (5,heater)], [partID:2, val: (6,mouse)], [partID:2,
            val: (7,cup)])&lt;br&gt;
            &lt;br&gt;
            &lt;br&gt;
            // now lets repartition but this time have it sorted&lt;br&gt;
            val partitioned = randRDD.repartitionAndSortWithinPartitions(rPartitioner)&lt;br&gt;
            def myfunc(index: Int, iter: Iterator[(Int, String)]) : Iterator[String] = {&lt;br&gt;
            &amp;nbsp; iter.toList.map(x =&amp;gt; &amp;ldquo;[partID:&amp;rdquo; +&amp;nbsp; index + &amp;ldquo;, val: &amp;rdquo; + x + &amp;ldquo;]&amp;rdquo;).iterator&lt;br&gt;
            }&lt;br&gt;
            partitioned.mapPartitionsWithIndex(myfunc).collect&lt;br&gt;
            &lt;br&gt;
            res1: Array[String] = Array([partID:0, val: (1,screen)], [partID:0,
            val: (2,cat)], [partID:0, val: (3,book)], [partID:1, val: (4,tv)],
            [partID:1, val: (5,heater)], [partID:2, val: (6,mouse)], [partID:2,
            val: (7,cup)])&lt;br&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
   &lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;br&gt;
&lt;a name=&quot;rightOuterJoin&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;/span&gt;&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;rightOuterJoin &lt;small&gt;[Pair]&lt;/small&gt;&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Performs an right outer join using two key-value RDDs. Please note that
the keys must be generally comparable to make this work correctly.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def rightOuterJoin&lt;a href=&quot;other:%0A%20%20%20RDD%5B(K,%20W)%5D&quot;&gt;W&lt;/a&gt;: RDD[(K, (Option[V], W))]&lt;br&gt;
   def rightOuterJoin&lt;a href=&quot;other:%20RDD%5B(K,%20W)%5D,%20numPartitions:%20Int&quot;&gt;W&lt;/a&gt;: RDD[(K,
   (Option[V], W))]&lt;br&gt;
   def rightOuterJoin&lt;a href=&quot;other:%20RDD%5B(K,%20W)%5D,%20partitioner:%20Partitioner&quot;&gt;W&lt;/a&gt;:
   RDD[(K, (Option[V], W))]
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(List(&amp;ldquo;dog&amp;rdquo;, &amp;ldquo;salmon&amp;rdquo;, &amp;ldquo;salmon&amp;rdquo;, &amp;ldquo;rat&amp;rdquo;, &amp;ldquo;elephant&amp;rdquo;),
               3)&lt;br&gt;
               val b = a.keyBy(&lt;/em&gt;.length)&lt;br&gt;
               val c =
               sc.parallelize(List(&amp;ldquo;dog&amp;rdquo;,&amp;ldquo;cat&amp;rdquo;,&amp;ldquo;gnu&amp;rdquo;,&amp;ldquo;salmon&amp;rdquo;,&amp;ldquo;rabbit&amp;rdquo;,&amp;ldquo;turkey&amp;rdquo;,&amp;ldquo;wolf&amp;rdquo;,&amp;ldquo;bear&amp;rdquo;,&amp;ldquo;bee&amp;rdquo;),
               3)&lt;br&gt;
               val d = c.keyBy(&lt;em&gt;.length)&lt;br&gt;
               b.rightOuterJoin(d).collect&lt;br&gt;
               &lt;br&gt;
               res2: Array[(Int, (Option[String], String))] =
               Array((6,(Some(salmon),salmon)), (6,(Some(salmon),rabbit)),
               (6,(Some(salmon),turkey)), (6,(Some(salmon),salmon)),
               (6,(Some(salmon),rabbit)), (6,(Some(salmon),turkey)),
               (3,(Some(dog),dog)), (3,(Some(dog),cat)), (3,(Some(dog),gnu)),
               (3,(Some(dog),bee)), (3,(Some(rat),dog)), (3,(Some(rat),cat)),
               (3,(Some(rat),gnu)), (3,(Some(rat),bee)), (4,(None,wolf)),
               (4,(None,bear)))
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;sample&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;sample&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Randomly selects a fraction of the items of a RDD and returns them in a
new RDD.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def sample(withReplacement:
   Boolean, fraction: Double, seed: Int): RDD[T]
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(1 to 10000, 3)&lt;br&gt;
               a.sample(false, 0.1, 0).count&lt;br&gt;
               res24: Long = 960&lt;br&gt;
               &lt;br&gt;
               a.sample(true, 0.3, 0).count&lt;br&gt;
               res25: Long = 2888&lt;br&gt;
               &lt;br&gt;
               a.sample(true, 0.3, 13).count&lt;br&gt;
               res26: Long = 2985
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;sampleByKey&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;sampleByKey&lt;/span&gt;&lt;/big&gt;&lt;/big&gt; [Pair]&lt;br&gt;
&lt;br&gt;
Randomly samples the key value pair RDD according to the fraction of each key you want to appear in the final RDD.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def sampleByKey(withReplacement: Boolean, fractions: Map[K, Double], seed: Long = Utils.random.nextLong): RDD[(K, V)]&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;table style=&quot;text-align: left; width: 640px; margin-left: 40px; height: 24px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
   &lt;tbody&gt;
      &lt;tr&gt;
         &lt;td style=&quot;vertical-align: top;&quot;&gt;val randRDD = sc.parallelize(List( (7,&amp;ldquo;cat&amp;rdquo;), (6, &amp;ldquo;mouse&amp;rdquo;),(7, &amp;ldquo;cup&amp;rdquo;), (6, &amp;ldquo;book&amp;rdquo;), (7, &amp;ldquo;tv&amp;rdquo;), (6, &amp;ldquo;screen&amp;rdquo;), (7, &amp;ldquo;heater&amp;rdquo;)))&lt;br&gt;
            val sampleMap = List((7, 0.4), (6, 0.6)).toMap&lt;br&gt;
            randRDD.sampleByKey(false, sampleMap,42).collect&lt;br&gt;
            &lt;br&gt;
            res6: Array[(Int, String)] = Array((7,cat), (6,mouse), (6,book), (6,screen), (7,heater))&lt;br&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
   &lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;a name=&quot;sampleByKeyExact&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;sampleByKeyExact&lt;/span&gt;&lt;/big&gt;&lt;/big&gt; [Pair, experimental]&lt;br&gt;
&lt;br&gt;
This is labelled as experimental and so we do not document it.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def sampleByKeyExact(withReplacement: Boolean, fractions: Map[K, Double], seed: Long = Utils.random.nextLong): RDD[(K, V)]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;saveAsHadoopFile&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;saveAsHadoopFile &lt;small&gt;[Pair]&lt;/small&gt;,
saveAsHadoopDataset &lt;small&gt;[Pair]&lt;/small&gt;, saveAsNewAPIHadoopFile &lt;small&gt;[Pair]&lt;/small&gt;&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Saves the RDD in a Hadoop compatible format using any Hadoop
outputFormat class the user specifies.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def saveAsHadoopDataset(conf:
   JobConf)&lt;br&gt;
   def saveAsHadoopFile&lt;a href=&quot;path:%20String&quot;&gt;F &amp;lt;: OutputFormat[K, V]&lt;/a&gt;(implicit
   fm: ClassTag[F])&lt;br&gt;
   def saveAsHadoopFile[F &amp;lt;: OutputFormat[K, V]](path: String, codec:
   Class[&lt;/em&gt; &amp;lt;: CompressionCodec]) (implicit fm: ClassTag[F])&lt;br&gt;
   def saveAsHadoopFile(path: String, keyClass: Class[&lt;em&gt;], valueClass:
   Class[&lt;/em&gt;], outputFormatClass: Class[_ &amp;lt;: OutputFormat[&lt;em&gt;, _]], codec:
   Class[&lt;/em&gt; &amp;lt;: CompressionCodec])&lt;br&gt;
   def saveAsHadoopFile(path: String, keyClass: Class[&lt;em&gt;], valueClass:
   Class[&lt;/em&gt;], outputFormatClass: Class[_ &amp;lt;: OutputFormat[&lt;em&gt;, _]], conf:
   JobConf = new JobConf(self.context.hadoopConfiguration), codec:
   Option[Class[&lt;/em&gt; &amp;lt;: CompressionCodec]] = None)&lt;br&gt;
   def saveAsNewAPIHadoopFile&lt;a href=&quot;path:%0A%20%20%20String&quot;&gt;F &amp;lt;: NewOutputFormat[K, V]&lt;/a&gt;(implicit fm: ClassTag[F])&lt;br&gt;
   def saveAsNewAPIHadoopFile(path: String, keyClass: Class[&lt;em&gt;],
   valueClass: Class[&lt;/em&gt;], outputFormatClass: Class[_ &amp;lt;:
   NewOutputFormat[&lt;em&gt;, _]], conf: Configuration =
   self.context.hadoopConfiguration)
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;saveAsObjectFile&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;saveAsObjectFile&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Saves the RDD in binary format.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def saveAsObjectFile(path: String)&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               x = sc.parallelize(1 to 100, 3)&lt;br&gt;
               x.saveAsObjectFile(&amp;ldquo;objFile&amp;rdquo;)&lt;br&gt;
               val y = sc.objectFile&lt;a href=&quot;%22objFile%22&quot;&gt;Int&lt;/a&gt;&lt;br&gt;
               y.collect&lt;br&gt;
               res52: Array[Int] =&amp;nbsp; Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8, 9,
               10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,
               28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45,
               46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
               64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81,
               82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,
               100)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;saveAsSequenceFile&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;saveAsSequenceFile &lt;small&gt;[SeqFile]&lt;/small&gt;&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Saves the RDD as a Hadoop sequence file.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def saveAsSequenceFile(path:
   String, codec: Option[Class[&lt;/em&gt; &amp;lt;: CompressionCodec]] = None)&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               v = sc.parallelize(Array((&amp;ldquo;owl&amp;rdquo;,3), (&amp;ldquo;gnu&amp;rdquo;,4), (&amp;ldquo;dog&amp;rdquo;,1), (&amp;ldquo;cat&amp;rdquo;,2),
               (&amp;ldquo;ant&amp;rdquo;,5)), 2)&lt;br&gt;
               v.saveAsSequenceFile(&amp;ldquo;hd_seq_file&amp;rdquo;)&lt;br&gt;
               14/04/19 05:45:43 INFO FileOutputCommitter: Saved output of task
               &amp;lsquo;attempt_201404190545_0000_m_000001_191&amp;rsquo; to
               file:/home/cloudera/hd_seq_file&lt;br&gt;
               &lt;br&gt;
               [cloudera@localhost ~]$ ll ~/hd_seq_file&lt;br&gt;
               total 8&lt;br&gt;
               -rwxr-xr-x 1 cloudera cloudera 117 Apr 19 05:45 part-00000&lt;br&gt;
               -rwxr-xr-x 1 cloudera cloudera 133 Apr 19 05:45 part-00001&lt;br&gt;
               -rwxr-xr-x 1 cloudera cloudera&amp;nbsp;&amp;nbsp; 0 Apr 19 05:45 &lt;em&gt;SUCCESS
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;saveAsTextFile&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;saveAsTextFile&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Saves the RDD as text files. One line at a time.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def saveAsTextFile(path: String)&lt;br&gt;
   def saveAsTextFile(path: String, codec: Class[&lt;/em&gt; &amp;lt;: CompressionCodec])&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example without compression&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(1 to 10000, 3)&lt;br&gt;
               a.saveAsTextFile(&amp;ldquo;mydata_a&amp;rdquo;)&lt;br&gt;
               14/04/03 21:11:36 INFO FileOutputCommitter: Saved output of task
               &amp;#39;attempt_201404032111_0000_m_000002_71&amp;rsquo; to
               file:/home/cloudera/Documents/spark-0.9.0-incubating-bin-cdh4/bin/mydata_a&lt;br&gt;
               &lt;br&gt;
               &lt;br&gt;
               [cloudera@localhost ~]$ head -n 5
               ~/Documents/spark-0.9.0-incubating-bin-cdh4/bin/mydata_a/part-00000&lt;br&gt;
               1&lt;br&gt;
               2&lt;br&gt;
               3&lt;br&gt;
               4&lt;br&gt;
               5&lt;br&gt;
               &lt;br&gt;
               // Produces 3 output files since we have created the a RDD with 3
               partitions&lt;br&gt;
               [cloudera@localhost ~]$ ll
               ~/Documents/spark-0.9.0-incubating-bin-cdh4/bin/mydata_a/&lt;br&gt;
               -rwxr-xr-x 1 cloudera cloudera 15558 Apr&amp;nbsp; 3 21:11 part-00000&lt;br&gt;
               -rwxr-xr-x 1 cloudera cloudera 16665 Apr&amp;nbsp; 3 21:11 part-00001&lt;br&gt;
               -rwxr-xr-x 1 cloudera cloudera 16671 Apr&amp;nbsp; 3 21:11 part-00002
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example with compression&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;import
               org.apache.hadoop.io.compress.GzipCodec&lt;br&gt;
               a.saveAsTextFile(&amp;ldquo;mydata_b&amp;rdquo;, classOf[GzipCodec])&lt;br&gt;
               &lt;br&gt;
               [cloudera@localhost ~]$ ll
               ~/Documents/spark-0.9.0-incubating-bin-cdh4/bin/mydata_b/&lt;br&gt;
               total 24&lt;br&gt;
               -rwxr-xr-x 1 cloudera cloudera 7276 Apr&amp;nbsp; 3 21:29 part-00000.gz&lt;br&gt;
               -rwxr-xr-x 1 cloudera cloudera 6517 Apr&amp;nbsp; 3 21:29 part-00001.gz&lt;br&gt;
               -rwxr-xr-x 1 cloudera cloudera 6525 Apr&amp;nbsp; 3 21:29 part-00002.gz&lt;br&gt;
               &lt;br&gt;
               val x = sc.textFile(&amp;ldquo;mydata_b&amp;rdquo;)&lt;br&gt;
               x.count&lt;br&gt;
               res2: Long = 10000
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example writing into HDFS&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               x = sc.parallelize(List(1,2,3,4,5,6,6,7,9,8,10,21), 3)&lt;br&gt;
               x.saveAsTextFile(&amp;ldquo;hdfs://localhost:8020/user/cloudera/test&amp;rdquo;);&lt;br&gt;
               &lt;br&gt;
               val sp = sc.textFile(&amp;ldquo;hdfs://localhost:8020/user/cloudera/sp_data&amp;rdquo;)&lt;br&gt;
               sp.flatMap(&lt;em&gt;.split(&amp;ldquo;
               &amp;rdquo;)).saveAsTextFile(&amp;ldquo;hdfs://localhost:8020/user/cloudera/sp_x&amp;rdquo;)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;stats&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;stats &lt;small&gt;[Double]&lt;/small&gt;&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Simultaneously computes the mean, variance and the standard deviation
of all values in the RDD.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def stats(): StatCounter&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               x = sc.parallelize(List(1.0, 2.0, 3.0, 5.0, 20.0, 19.02, 19.29, 11.09,
               21.0), 2)&lt;br&gt;
               x.stats&lt;br&gt;
               res16: org.apache.spark.util.StatCounter = (count: 9, mean: 11.266667,
               stdev: 8.126859)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;a name=&quot;sortBy&quot;&gt;&lt;/a&gt;&lt;br&gt;
sortBy&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
This function sorts the input RDD&amp;rsquo;s data and stores it in a new RDD.
The first parameter requires you to specify a function which&amp;nbsp; maps
the input data into the key that you want to sortBy. The second
parameter (optional) specifies whether you want the data to be sorted
in ascending or descending order.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def sortBy&lt;a href=&quot;f:%20(T)%20%E2%87%92%20K,%0A%20%20%20ascending:%20Boolean%20=%20true,%20numPartitions:%20Int%20=%0A%20%20%20this.partitions.size&quot;&gt;K&lt;/a&gt;(implicit ord: Ordering[K], ctag: ClassTag[K]):
   RDD[T]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;
&lt;table style=&quot;text-align: left; width: 686px; height: 28px; margin-left: 40px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
   &lt;tbody&gt;
      &lt;tr&gt;
         &lt;td style=&quot;vertical-align: top;&quot;&gt;&lt;br&gt;
            val y = sc.parallelize(Array(5, 7, 1, 3, 2, 1))&lt;br&gt;
            y.sortBy(c =&amp;gt; c, true).collect&lt;br&gt;
            res101: Array[Int] = Array(1, 1, 2, 3, 5, 7)&lt;br&gt;
            &lt;br&gt;
            y.sortBy(c =&amp;gt; c, false).collect&lt;br&gt;
            res102: Array[Int] = Array(7, 5, 3, 2, 1, 1)&lt;br&gt;
            &lt;br&gt;
            val z = sc.parallelize(Array((&amp;ldquo;H&amp;rdquo;, 10), (&amp;ldquo;A&amp;rdquo;, 26), (&amp;ldquo;Z&amp;rdquo;, 1), (&amp;ldquo;L&amp;rdquo;, 5)))&lt;br&gt;
            z.sortBy(c =&amp;gt; c._1, true).collect&lt;br&gt;
            res109: Array[(String, Int)] = Array((A,26), (H,10), (L,5), (Z,1))&lt;br&gt;
            &lt;br&gt;
            z.sortBy(c =&amp;gt; c._2, true).collect&lt;br&gt;
            res108: Array[(String, Int)] = Array((Z,1), (L,5), (H,10), (A,26))&lt;br&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
   &lt;/tbody&gt;
&lt;/table&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;br&gt;
&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;
&lt;a name=&quot;sortByKey&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
sortByKey &lt;small&gt;[Ordered]&lt;/small&gt;&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
This function sorts the input RDD&amp;rsquo;s data and stores it in a new RDD.
The output RDD is a shuffled RDD because it stores data that is output
by a reducer which has been shuffled. The implementation of this
function is actually very clever. First, it uses a range partitioner to
partition the data in ranges within the shuffled RDD. Then it sorts
these ranges individually with mapPartitions using standard sort
mechanisms.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def sortByKey(ascending: Boolean
   = true, numPartitions: Int = self.partitions.size): RDD[P]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(List(&amp;ldquo;dog&amp;rdquo;, &amp;ldquo;cat&amp;rdquo;, &amp;ldquo;owl&amp;rdquo;, &amp;ldquo;gnu&amp;rdquo;, &amp;ldquo;ant&amp;rdquo;), 2)&lt;br&gt;
               val b = sc.parallelize(1 to a.count.toInt, 2)&lt;br&gt;
               val c = a.zip(b)&lt;br&gt;
               c.sortByKey(true).collect&lt;br&gt;
               res74: Array[(String, Int)] = Array((ant,5), (cat,2), (dog,1), (gnu,4),
               (owl,3))&lt;br&gt;
               c.sortByKey(false).collect&lt;br&gt;
               res75: Array[(String, Int)] = Array((owl,3), (gnu,4), (dog,1), (cat,2),
               (ant,5))&lt;br&gt;
               &lt;br&gt;
               val a = sc.parallelize(1 to 100, 5)&lt;br&gt;
               val b = a.cartesian(a)&lt;br&gt;
               val c = sc.parallelize(b.takeSample(true, 5, 13), 2)&lt;br&gt;
               val d = c.sortByKey(false)&lt;br&gt;
               res56: Array[(Int, Int)] = Array((96,9), (84,76), (59,59), (53,65),
               (52,4))
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;stdev&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;stdev &lt;small&gt;[Double],
sampleStdev [Double]&lt;/small&gt;&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Calls &lt;span style=&quot;font-style: italic;&quot;&gt;stats&lt;/span&gt; and extracts
either &lt;span style=&quot;font-style: italic;&quot;&gt;stdev&lt;/span&gt;-component or
corrected &lt;span style=&quot;font-style: italic;&quot;&gt;sampleStdev&lt;/span&gt;-component.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def stdev(): Double&lt;br&gt;
   def sampleStdev(): Double&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               d = sc.parallelize(List(0.0, 0.0, 0.0), 3)&lt;br&gt;
               d.stdev&lt;br&gt;
               res10: Double = 0.0&lt;br&gt;
               d.sampleStdev&lt;br&gt;
               res11: Double = 0.0&lt;br&gt;
               &lt;br&gt;
               val d = sc.parallelize(List(0.0, 1.0), 3)&lt;br&gt;
               d.stdev&lt;br&gt;
               d.sampleStdev&lt;br&gt;
               res18: Double = 0.5&lt;br&gt;
               res19: Double = 0.7071067811865476&lt;br&gt;
               &lt;br&gt;
               val d = sc.parallelize(List(0.0, 0.0, 1.0), 3)&lt;br&gt;
               d.stdev&lt;br&gt;
               res14: Double = 0.4714045207910317&lt;br&gt;
               d.sampleStdev&lt;br&gt;
               res15: Double = 0.5773502691896257
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;subtract&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;subtract&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Performs the well known standard set subtraction operation: A - B&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def subtract(other: RDD[T]):
   RDD[T]&lt;br&gt;
   def subtract(other: RDD[T], numPartitions: Int): RDD[T]&lt;br&gt;
   def subtract(other: RDD[T], p: Partitioner): RDD[T]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(1 to 9, 3)&lt;br&gt;
               val b = sc.parallelize(1 to 3, 3)&lt;br&gt;
               val c = a.subtract(b)&lt;br&gt;
               c.collect&lt;br&gt;
               res3: Array[Int] = Array(6, 9, 4, 7, 5, 8)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;subtractByKey&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;subtractByKey &lt;small&gt;[Pair]&lt;/small&gt;&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Very similar to &lt;span style=&quot;font-style: italic;&quot;&gt;subtract&lt;/span&gt;, but
instead of supplying a function, the key-component of each pair will be
automatically used as criterion for removing items from the first RDD.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def subtractByKey&lt;a href=&quot;other:%20RDD%5B(K,%20W)%5D&quot;&gt;W:
   ClassTag&lt;/a&gt;: RDD[(K, V)]&lt;br&gt;
   def subtractByKey&lt;a href=&quot;other:%20RDD%5B(K,%20W)%5D,%20numPartitions:%20Int&quot;&gt;W: ClassTag&lt;/a&gt;:
   RDD[(K, V)]&lt;br&gt;
   def subtractByKey&lt;a href=&quot;other:%20RDD%5B(K,%20W)%5D,%20p:%20Partitioner&quot;&gt;W: ClassTag&lt;/a&gt;:
   RDD[(K, V)]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(List(&amp;ldquo;dog&amp;rdquo;, &amp;ldquo;tiger&amp;rdquo;, &amp;ldquo;lion&amp;rdquo;, &amp;ldquo;cat&amp;rdquo;, &amp;ldquo;spider&amp;rdquo;,
               &amp;ldquo;eagle&amp;rdquo;), 2)&lt;br&gt;
               val b = a.keyBy(&lt;/em&gt;.length)&lt;br&gt;
               val c = sc.parallelize(List(&amp;ldquo;ant&amp;rdquo;, &amp;ldquo;falcon&amp;rdquo;, &amp;ldquo;squid&amp;rdquo;), 2)&lt;br&gt;
               val d = c.keyBy(&lt;em&gt;.length)&lt;br&gt;
               b.subtractByKey(d).collect&lt;br&gt;
               res15: Array[(Int, String)] = Array((4,lion))
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;sum&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;sum &lt;small&gt;[Double],
sumApprox [Double]&lt;/small&gt;&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Computes the sum of all values contained in the RDD. The approximate
version of the function can finish somewhat faster in some scenarios.
However, it trades accuracy for speed.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def sum(): Double&lt;br&gt;
   def sumApprox(timeout: Long, confidence: Double = 0.95):
   PartialResult[BoundedDouble]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               x = sc.parallelize(List(1.0, 2.0, 3.0, 5.0, 20.0, 19.02, 19.29, 11.09,
               21.0), 2)&lt;br&gt;
               x.sum&lt;br&gt;
               res17: Double = 101.39999999999999
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;take&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;take&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Extracts the first &lt;span style=&quot;font-style: italic;&quot;&gt;n&lt;/span&gt; items of
the RDD and returns them as an array. &lt;span style=&quot;font-style: italic;&quot;&gt;(Note:
This sounds very easy, but it is actually quite a tricky problem for
the implementors of Spark because the items in question can be in many
different partitions.)&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def take(num: Int): Array[T]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               b = sc.parallelize(List(&amp;ldquo;dog&amp;rdquo;, &amp;ldquo;cat&amp;rdquo;, &amp;ldquo;ape&amp;rdquo;, &amp;ldquo;salmon&amp;rdquo;, &amp;ldquo;gnu&amp;rdquo;), 2)&lt;br&gt;
               b.take(2)&lt;br&gt;
               res18: Array[String] = Array(dog, cat)&lt;br&gt;
               &lt;br&gt;
               val b = sc.parallelize(1 to 10000, 5000)&lt;br&gt;
               b.take(100)&lt;br&gt;
               res6: Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
               15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
               33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
               51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68,
               69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86,
               87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;takeOrdered&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;takeOrdered&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Orders the data items of the RDD using their inherent implicit ordering
function and returns the first &lt;span style=&quot;font-style: italic;&quot;&gt;n&lt;/span&gt;
items as an array.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def takeOrdered(num:
   Int)(implicit ord: Ordering[T]): Array[T]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               b = sc.parallelize(List(&amp;ldquo;dog&amp;rdquo;, &amp;ldquo;cat&amp;rdquo;, &amp;ldquo;ape&amp;rdquo;, &amp;ldquo;salmon&amp;rdquo;, &amp;ldquo;gnu&amp;rdquo;), 2)&lt;br&gt;
               b.takeOrdered(2)&lt;br&gt;
               res19: Array[String] = Array(ape, cat)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;takeSample&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;takeSample&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Behaves different from &lt;span style=&quot;font-style: italic;&quot;&gt;sample&lt;/span&gt;
in the following respects:&lt;br&gt;
&lt;ul&gt;
   &lt;li&gt;&amp;nbsp; It will return an exact number of samples &lt;span style=&quot;font-style: italic;&quot;&gt;(Hint: 2nd parameter)&lt;/span&gt;&lt;/li&gt;
   &lt;li&gt;&amp;nbsp; It returns an Array instead of RDD.&lt;/li&gt;
   &lt;li&gt;&amp;nbsp; It internally randomizes the order of the items
      returned.
   &lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def takeSample(withReplacement:
   Boolean, num: Int, seed: Int): Array[T]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               x = sc.parallelize(1 to 1000, 3)&lt;br&gt;
               x.takeSample(true, 100, 1)&lt;br&gt;
               res3: Array[Int] = Array(339, 718, 810, 105, 71, 268, 333, 360, 341,
               300, 68, 848, 431, 449, 773, 172, 802, 339, 431, 285, 937, 301, 167,
               69, 330, 864, 40, 645, 65, 349, 613, 468, 982, 314, 160, 675, 232, 794,
               577, 571, 805, 317, 136, 860, 522, 45, 628, 178, 321, 482, 657, 114,
               332, 728, 901, 290, 175, 876, 227, 130, 863, 773, 559, 301, 694, 460,
               839, 952, 664, 851, 260, 729, 823, 880, 792, 964, 614, 821, 683, 364,
               80, 875, 813, 951, 663, 344, 546, 918, 436, 451, 397, 670, 756, 512,
               391, 70, 213, 896, 123, 858)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;toDebugString&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;toDebugString&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Returns a string that contains debug information about the RDD and its
dependencies.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def toDebugString: String&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(1 to 9, 3)&lt;br&gt;
               val b = sc.parallelize(1 to 3, 3)&lt;br&gt;
               val c = a.subtract(b)&lt;br&gt;
               c.toDebugString&lt;br&gt;
               res6: String = &lt;br&gt;
               MappedRDD[15] at subtract at &amp;lt;console&amp;gt;:16 (3 partitions)&lt;br&gt;
               &amp;nbsp; SubtractedRDD[14] at subtract at &amp;lt;console&amp;gt;:16 (3
               partitions)&lt;br&gt;
               &amp;nbsp;&amp;nbsp;&amp;nbsp; MappedRDD[12] at subtract at &amp;lt;console&amp;gt;:16 (3
               partitions)&lt;br&gt;
               &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ParallelCollectionRDD[10] at parallelize
               at &amp;lt;console&amp;gt;:12 (3 partitions)&lt;br&gt;
               &amp;nbsp;&amp;nbsp;&amp;nbsp; MappedRDD[13] at subtract at &amp;lt;console&amp;gt;:16 (3
               partitions)&lt;br&gt;
               &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ParallelCollectionRDD[11] at parallelize
               at &amp;lt;console&amp;gt;:12 (3 partitions)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;toJavaRDD&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;toJavaRDD&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Embeds this RDD object within a JavaRDD object and returns it.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def toJavaRDD() : JavaRDD[T]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               c = sc.parallelize(List(&amp;ldquo;Gnu&amp;rdquo;, &amp;ldquo;Cat&amp;rdquo;, &amp;ldquo;Rat&amp;rdquo;, &amp;ldquo;Dog&amp;rdquo;), 2)&lt;br&gt;
               c.toJavaRDD&lt;br&gt;
               res3: org.apache.spark.api.java.JavaRDD[String] =
               ParallelCollectionRDD[6] at parallelize at &amp;lt;console&amp;gt;:12
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;toLocalIterator&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;toLocalIterator&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Converts the RDD into a scala iterator at the master node.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def toLocalIterator: Iterator[T]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;table style=&quot;text-align: left; width: 627px; margin-left: 40px; height: 28px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
   &lt;tbody&gt;
      &lt;tr&gt;
         &lt;td style=&quot;vertical-align: top;&quot;&gt;val z = sc.parallelize(List(1,2,3,4,5,6), 2)&lt;br&gt;
            val iter = z.toLocalIterator&lt;br&gt;
            &lt;br&gt;
            iter.next&lt;br&gt;
            res51: Int = 1&lt;br&gt;
            &lt;br&gt;
            iter.next&lt;br&gt;
            res52: Int = 2&lt;br&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
   &lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;top&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;top&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Utilizes the implicit ordering of $T$ to determine the top $k$ values
and returns them as an array.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;ddef top(num: Int)(implicit ord:
   Ordering[T]): Array[T]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               c = sc.parallelize(Array(6, 9, 4, 7, 5, 8), 2)&lt;br&gt;
               c.top(2)&lt;br&gt;
               res28: Array[Int] = Array(9, 8)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;toString&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;toString&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Assembles a human-readable textual description of the RDD.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;override def toString: String&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val z = sc.parallelize(List(1,2,3,4,5,6), 2)&lt;br&gt;
               z.toString&lt;br&gt;
               res61: String = ParallelCollectionRDD[80] at parallelize at &amp;lt;console&amp;gt;:21&lt;br&gt;
               &lt;br&gt;
               val randRDD = sc.parallelize(List( (7,&amp;ldquo;cat&amp;rdquo;), (6, &amp;ldquo;mouse&amp;rdquo;),(7, &amp;ldquo;cup&amp;rdquo;), (6, &amp;ldquo;book&amp;rdquo;), (7, &amp;ldquo;tv&amp;rdquo;), (6, &amp;ldquo;screen&amp;rdquo;), (7, &amp;ldquo;heater&amp;rdquo;)))&lt;br&gt;
               val sortedRDD = randRDD.sortByKey()&lt;br&gt;
               sortedRDD.toString&lt;br&gt;
               res64: String = ShuffledRDD[88] at sortByKey at &amp;lt;console&amp;gt;:23&lt;br&gt;
               &lt;br&gt;
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;treeAggregate&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;treeAggregate&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Computes the same thing as aggregate, except it aggregates the elements
of the RDD in a multi-level tree pattern. Another difference is that it
does not use the initial value for the second reduce function
(combOp).&amp;nbsp; By default a tree of depth 2 is used, but this can be
changed via the depth parameter.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def treeAggregate&lt;a href=&quot;zeroValue:%20U&quot;&gt;U&lt;/a&gt;(seqOp: (U, T) ⇒ U, combOp: (U, U) ⇒ U, depth: Int = 2)(implicit arg0: ClassTag[U]): U&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;table style=&quot;text-align: left; width: 713px; margin-left: 40px; height: 376px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
   &lt;tbody&gt;
      &lt;tr&gt;
         &lt;td style=&quot;vertical-align: top;&quot;&gt;val z = sc.parallelize(List(1,2,3,4,5,6), 2)&lt;br&gt;
            &lt;br&gt;
            // lets first print out the contents of the RDD with partition labels&lt;br&gt;
            def myfunc(index: Int, iter: Iterator[(Int)]) : Iterator[String] = {&lt;br&gt;
            &amp;nbsp; iter.toList.map(x =&amp;gt; &amp;ldquo;[partID:&amp;rdquo; +&amp;nbsp; index + &amp;ldquo;, val: &amp;rdquo; + x + &amp;ldquo;]&amp;rdquo;).iterator&lt;br&gt;
            }&lt;br&gt;
            &lt;br&gt;
            z.mapPartitionsWithIndex(myfunc).collect&lt;br&gt;
            res28: Array[String] = Array([partID:0, val: 1], [partID:0, val: 2],
            [partID:0, val: 3], [partID:1, val: 4], [partID:1, val: 5], [partID:1,
            val: 6])&lt;br&gt;
            &lt;br&gt;
            z.treeAggregate(0)(math.max(&lt;/em&gt;, &lt;em&gt;), _ + _)&lt;br&gt;
            res40: Int = 9&lt;br&gt;
            &lt;br&gt;
            // Note unlike normal aggregrate. Tree aggregate does not apply the initial value for the second reduce&lt;br&gt;
            // This example returns 11 since the initial value is 5&lt;br&gt;
            // reduce of partition 0 will be max(5, 1, 2, 3) = 5&lt;br&gt;
            // reduce of partition 1 will be max(4, 5, 6) = 6&lt;br&gt;
            // final reduce across partitions will be 5 + 6 = 11&lt;br&gt;
            // note the final reduce does not include the initial value&lt;br&gt;
            z.treeAggregate(5)(math.max(&lt;/em&gt;, &lt;em&gt;), _ + _)&lt;br&gt;
            res42: Int = 11
         &lt;/td&gt;
      &lt;/tr&gt;
   &lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;treeReduce&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;treeReduce&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Works like reduce except reduces the elements of the RDD in a multi-level tree pattern.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def&amp;nbsp; treeReduce(f: (T, T) ⇒ T, depth: Int = 2): T&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;table style=&quot;text-align: left; width: 753px; margin-left: 40px; height: 43px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
   &lt;tbody&gt;
      &lt;tr&gt;
         &lt;td style=&quot;vertical-align: top;&quot;&gt;val z = sc.parallelize(List(1,2,3,4,5,6), 2)&lt;br&gt;
            z.treeReduce(&lt;/em&gt;+&lt;em&gt;)&lt;br&gt;
            res49: Int = 21&lt;br&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
   &lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;union&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;union, ++&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Performs the standard set operation: A union B&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def ++(other: RDD[T]): RDD[T]&lt;br&gt;
   def union(other: RDD[T]): RDD[T]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(1 to 3, 1)&lt;br&gt;
               val b = sc.parallelize(5 to 7, 1)&lt;br&gt;
               (a ++ b).collect&lt;br&gt;
               res0: Array[Int] = Array(1, 2, 3, 5, 6, 7)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;unpersist&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;unpersist&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Dematerializes the RDD &lt;span style=&quot;font-style: italic;&quot;&gt;(i.e. Erases
all data items from hard-disk and memory)&lt;/span&gt;.
However, the RDD object remains. If it is referenced in a computation,
Spark will regenerate it automatically using the stored dependency
graph.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def unpersist(blocking: Boolean =
   true): RDD[T]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               y = sc.parallelize(1 to 10, 10)&lt;br&gt;
               val z = (y++y)&lt;br&gt;
               z.collect&lt;br&gt;
               z.unpersist(true)&lt;br&gt;
               14/04/19 03:04:57 INFO UnionRDD: Removing RDD 22 from persistence list&lt;br&gt;
               14/04/19 03:04:57 INFO BlockManager: Removing RDD 22
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;values&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;values&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Extracts the values from all contained tuples and returns them in a new
RDD.&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def values: RDD[V]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(List(&amp;ldquo;dog&amp;rdquo;, &amp;ldquo;tiger&amp;rdquo;, &amp;ldquo;lion&amp;rdquo;, &amp;ldquo;cat&amp;rdquo;, &amp;ldquo;panther&amp;rdquo;,
               &amp;ldquo;eagle&amp;rdquo;), 2)&lt;br&gt;
               val b = a.map(x =&amp;gt; (x.length, x))&lt;br&gt;
               b.values.collect&lt;br&gt;
               res3: Array[String] = Array(dog, tiger, lion, cat, panther, eagle)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;variance&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;variance &lt;small&gt;[Double]&lt;/small&gt;,
sampleVariance &lt;small&gt;[Double]&lt;/small&gt;&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Calls stats and extracts either &lt;span style=&quot;font-style: italic;&quot;&gt;variance&lt;/span&gt;-component
or corrected &lt;span style=&quot;font-style: italic;&quot;&gt;sampleVariance&lt;/span&gt;-component.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def variance(): Double&lt;br&gt;
   def sampleVariance(): Double&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(List(9.1, 1.0, 1.2, 2.1, 1.3, 5.0, 2.0, 2.1, 7.4,
               7.5, 7.6, 8.8, 10.0, 8.9, 5.5), 3)&lt;br&gt;
               a.variance&lt;br&gt;
               res70: Double = 10.605333333333332&lt;br&gt;
               &lt;br&gt;
               val x = sc.parallelize(List(1.0, 2.0, 3.0, 5.0, 20.0, 19.02, 19.29,
               11.09, 21.0), 2)&lt;br&gt;
               x.variance&lt;br&gt;
               res14: Double = 66.04584444444443&lt;br&gt;
               &lt;br&gt;
               x.sampleVariance&lt;br&gt;
               res13: Double = 74.30157499999999
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;zip&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;zip&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Joins two RDDs by combining the i-th of either partition with each
other. The resulting RDD will consist of two-component tuples which are
interpreted as key-value pairs by the methods provided by the
PairRDDFunctions extension.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def zip&lt;a href=&quot;other:%0A%20%20%20RDD%5BU%5D&quot;&gt;U: ClassTag&lt;/a&gt;: RDD[(T, U)]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(1 to 100, 3)&lt;br&gt;
               val b = sc.parallelize(101 to 200, 3)&lt;br&gt;
               a.zip(b).collect&lt;br&gt;
               res1: Array[(Int, Int)] = Array((1,101), (2,102), (3,103), (4,104),
               (5,105), (6,106), (7,107), (8,108), (9,109), (10,110), (11,111),
               (12,112), (13,113), (14,114), (15,115), (16,116), (17,117), (18,118),
               (19,119), (20,120), (21,121), (22,122), (23,123), (24,124), (25,125),
               (26,126), (27,127), (28,128), (29,129), (30,130), (31,131), (32,132),
               (33,133), (34,134), (35,135), (36,136), (37,137), (38,138), (39,139),
               (40,140), (41,141), (42,142), (43,143), (44,144), (45,145), (46,146),
               (47,147), (48,148), (49,149), (50,150), (51,151), (52,152), (53,153),
               (54,154), (55,155), (56,156), (57,157), (58,158), (59,159), (60,160),
               (61,161), (62,162), (63,163), (64,164), (65,165), (66,166), (67,167),
               (68,168), (69,169), (70,170), (71,171), (72,172), (73,173), (74,174),
               (75,175), (76,176), (77,177), (78,&amp;hellip;&lt;br&gt;
               &lt;br&gt;
               val a = sc.parallelize(1 to 100, 3)&lt;br&gt;
               val b = sc.parallelize(101 to 200, 3)&lt;br&gt;
               val c = sc.parallelize(201 to 300, 3)&lt;br&gt;
               a.zip(b).zip&amp;copy;.map((x) =&amp;gt; (x.&lt;/em&gt;1._1, x._1._2, x._2 )).collect&lt;br&gt;
               res12: Array[(Int, Int, Int)] = Array((1,101,201), (2,102,202),
               (3,103,203), (4,104,204), (5,105,205), (6,106,206), (7,107,207),
               (8,108,208), (9,109,209), (10,110,210), (11,111,211), (12,112,212),
               (13,113,213), (14,114,214), (15,115,215), (16,116,216), (17,117,217),
               (18,118,218), (19,119,219), (20,120,220), (21,121,221), (22,122,222),
               (23,123,223), (24,124,224), (25,125,225), (26,126,226), (27,127,227),
               (28,128,228), (29,129,229), (30,130,230), (31,131,231), (32,132,232),
               (33,133,233), (34,134,234), (35,135,235), (36,136,236), (37,137,237),
               (38,138,238), (39,139,239), (40,140,240), (41,141,241), (42,142,242),
               (43,143,243), (44,144,244), (45,145,245), (46,146,246), (47,147,247),
               (48,148,248), (49,149,249), (50,150,250), (51,151,251), (52,152,252),
               (53,153,253), (54,154,254), (55,155,255)&amp;hellip;
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;br&gt;
&lt;a name=&quot;zipPartitions&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;zipParititions&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Similar to &lt;span style=&quot;font-style: italic;&quot;&gt;zip&lt;/span&gt;. But provides
more control over the zipping process.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def zipPartitions&lt;a href=&quot;rdd2:%20RDD%5BB%5D&quot;&gt;B: ClassTag, V:
   ClassTag&lt;/a&gt;(f: (Iterator[T], Iterator[B]) =&amp;gt;
   Iterator[V]): RDD[V]&lt;br&gt;
   def zipPartitions&lt;a href=&quot;rdd2:%20RDD%5BB%5D,%0A%20%20%20preservesPartitioning:%20Boolean&quot;&gt;B: ClassTag, V: ClassTag&lt;/a&gt;(f: (Iterator[T], Iterator[B]) =&amp;gt;
   Iterator[V]): RDD[V]&lt;br&gt;
   def zipPartitions&lt;a href=&quot;rdd2:%20RDD%5BB%5D,%0A%20%20%20rdd3:%20RDD%5BC%5D&quot;&gt;B: ClassTag, C: ClassTag, V: ClassTag&lt;/a&gt;(f: (Iterator[T], Iterator[B], Iterator[C]) =&amp;gt;
   Iterator[V]): RDD[V]&lt;br&gt;
   def zipPartitions&lt;a href=&quot;rdd2:%20RDD%5BB%5D,%0A%20%20%20rdd3:%20RDD%5BC%5D,%20preservesPartitioning:%20Boolean&quot;&gt;B: ClassTag, C: ClassTag, V: ClassTag&lt;/a&gt;(f: (Iterator[T],
   Iterator[B], Iterator[C]) =&amp;gt; Iterator[V]): RDD[V]&lt;br&gt;
   def zipPartitions&lt;a href=&quot;rdd2:%20RDD%5BB%5D,%20rdd3:%20RDD%5BC%5D,%20rdd4:%20RDD%5BD%5D&quot;&gt;B: ClassTag, C: ClassTag, D: ClassTag, V:
   ClassTag&lt;/a&gt;(f: (Iterator[T],
   Iterator[B], Iterator[C], Iterator[D]) =&amp;gt; Iterator[V]): RDD[V]&lt;br&gt;
   def zipPartitions&lt;a href=&quot;rdd2:%20RDD%5BB%5D,%20rdd3:%20RDD%5BC%5D,%20rdd4:%20RDD%5BD%5D,%0A%20%20%20preservesPartitioning:%20Boolean&quot;&gt;B: ClassTag, C: ClassTag, D: ClassTag, V:
   ClassTag&lt;/a&gt;(f: (Iterator[T], Iterator[B],
   Iterator[C], Iterator[D]) =&amp;gt; Iterator[V]): RDD[V]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;
   &lt;table style=&quot;text-align: left; width: 586px; height: 54px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
      &lt;tbody&gt;
         &lt;tr&gt;
            &lt;td style=&quot;vertical-align: top; background-color: rgb(242, 242, 242);&quot;&gt;val
               a = sc.parallelize(0 to 9, 3)&lt;br&gt;
               val b = sc.parallelize(10 to 19, 3)&lt;br&gt;
               val c = sc.parallelize(100 to 109, 3)&lt;br&gt;
               def myfunc(aiter: Iterator[Int], biter: Iterator[Int], citer:
               Iterator[Int]): Iterator[String] =&lt;br&gt;
               {&lt;br&gt;
               &amp;nbsp; var res = List&lt;a href=&quot;&quot;&gt;String&lt;/a&gt;&lt;br&gt;
               &amp;nbsp; while (aiter.hasNext &amp;amp;&amp;amp; biter.hasNext &amp;amp;&amp;amp;
               citer.hasNext)&lt;br&gt;
               &amp;nbsp; {&lt;br&gt;
               &amp;nbsp;&amp;nbsp;&amp;nbsp; val x = aiter.next + &amp;ldquo; &amp;rdquo; + biter.next + &amp;ldquo; &amp;rdquo; +
               citer.next&lt;br&gt;
               &amp;nbsp;&amp;nbsp;&amp;nbsp; res ::= x&lt;br&gt;
               &amp;nbsp; }&lt;br&gt;
               &amp;nbsp; res.iterator&lt;br&gt;
               }&lt;br&gt;
               a.zipPartitions(b, c)(myfunc).collect&lt;br&gt;
               res50: Array[String] = Array(2 12 102, 1 11 101, 0 10 100, 5 15 105, 4
               14 104, 3 13 103, 9 19 109, 8 18 108, 7 17 107, 6 16 106)
            &lt;/td&gt;
         &lt;/tr&gt;
      &lt;/tbody&gt;
   &lt;/table&gt;
   &lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;a name=&quot;zipWithIndex&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;zipWithIndex&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
Zips the elements of the RDD with its element indexes. The indexes
start from 0. If the RDD is spread across multiple partitions then a
spark Job is started to perform this operation.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def zipWithIndex(): RDD[(T, Long)]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;table style=&quot;text-align: left; width: 629px; height: 28px; margin-left: 40px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
   &lt;tbody&gt;
      &lt;tr&gt;
         &lt;td style=&quot;vertical-align: top;&quot;&gt;val z =
            sc.parallelize(Array(&amp;ldquo;A&amp;rdquo;, &amp;ldquo;B&amp;rdquo;, &amp;ldquo;C&amp;rdquo;, &amp;ldquo;D&amp;rdquo;))&lt;br&gt;
            val r = z.zipWithIndex&lt;br&gt;
            res110: Array[(String, Long)] = Array((A,0), (B,1), (C,2), (D,3))&lt;br&gt;
            &lt;br&gt;
            val z = sc.parallelize(100 to 120, 5)&lt;br&gt;
            val r = z.zipWithIndex&lt;br&gt;
            r.collect&lt;br&gt;res11:
            Array[(Int, Long)] = Array((100,0), (101,1), (102,2), (103,3), (104,4),
            (105,5), (106,6), (107,7), (108,8), (109,9), (110,10), (111,11),
            (112,12), (113,13), (114,14), (115,15), (116,16), (117,17), (118,18),
            (119,19), (120,20))&lt;br&gt;
            &lt;br&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
   &lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;br&gt;
&lt;hr style=&quot;width: 100%; height: 2px;&quot;&gt;
&lt;a name=&quot;zipWithUniqueId&quot;&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;big&gt;&lt;big&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;zipWithUniqueId&lt;/span&gt;&lt;/big&gt;&lt;/big&gt;&lt;br&gt;
&lt;br&gt;
This is different from zipWithIndex since just gives a unique id to
each data element but the ids may not match the index number of the
data element. This operation does not start a spark job even if the RDD
is spread across multiple partitions.&lt;br&gt;
Compare the results of the example below with that of the 2nd example
of zipWithIndex. You should be able to see the difference.&lt;br&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Listing Variants&lt;br&gt;
&lt;/span&gt;&lt;br&gt;
&lt;div style=&quot;margin-left: 40px;&quot;&gt;def zipWithUniqueId(): RDD[(T,
   Long)]&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;span style=&quot;font-weight: bold;&quot;&gt;Example&lt;/span&gt;&lt;br&gt;
&lt;br&gt;
&lt;table style=&quot;text-align: left; width: 672px; margin-left: 40px; height: 28px;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt;
   &lt;tbody&gt;
      &lt;tr&gt;
         &lt;td style=&quot;vertical-align: top;&quot;&gt;val z = sc.parallelize(100
            to 120, 5)&lt;br&gt;
            val r = z.zipWithUniqueId&lt;br&gt;
            r.collect&lt;br&gt;
            &lt;br&gt;res12:
            Array[(Int, Long)] = Array((100,0), (101,5), (102,10), (103,15),
            (104,1), (105,6), (106,11), (107,16), (108,2), (109,7), (110,12),
            (111,17), (112,3), (113,8), (114,13), (115,18), (116,4), (117,9),
            (118,14), (119,19), (120,24))&lt;br&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
   &lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 26 Jan 2017 00:00:00 +0800</pubDate>
        <link>/2017/01/26/rdd.html</link>
        <guid isPermaLink="true">/2017/01/26/rdd.html</guid>
        
        
      </item>
    
      <item>
        <title>Hive中增加列隐藏的问题</title>
        <description>&lt;p&gt;有个hive表&lt;code&gt;id_zone&lt;/code&gt;，存储按地理位置哈希值汇聚的订单信息，按天划分partition，表建好且跑了几天数据之后，想加经纬度两列进去，就执行了如下语句：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid_zone&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;column&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;geohash_lat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid_zone&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;column&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;geohash_lng&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表见好之后，用&lt;code&gt;show create table mid_zone&lt;/code&gt;,和&lt;code&gt;show columns in mid_zone&lt;/code&gt;命令查看发现两列已经建进去了，就又重新跑了前几天的数据，想把经纬度值更新进去，但无论怎么执行，两列都是NULL，起初怀疑是解析地理位置哈希的UDF写的有问题，但测试了好几次都能正确解析出数值，后来又直接把经纬度写了两个固定的数值进去看看，但也写不进去，那就不是UDF的问题了。
后来突然想起之前看到过添加列语句后面可以加cascade关键字，特意查了下，如果不加这个的话，只会修改metadata，也就是新的partition会包含添加的字段，而不会更新旧的partitions，&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL&quot;&gt;官方说明&lt;/a&gt;是这样写的：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;The CASCADE|RESTRICT clause is available in Hive 0.15.0.
ALTER TABLE CHANGE COLUMN with CASCADE command changes the columns of a table&amp;#39;s metadata
 ,and cascades the same change to all the partition metadata. 
RESTRICT is the default, limiting column change only to table metadata.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以我又把这两列删掉，重新执行了如下命令就好了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid_zone&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;column&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;geohash_lat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;cascade&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid_zone&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;column&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;geohash_lng&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;cascade&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，如果partition特别多的话，执行起来会非常慢，因为要更新每个partition。
如果条件允许的话，将表drop掉之后重新create也是可以的。&lt;/p&gt;
</description>
        <pubDate>Fri, 14 Oct 2016 00:00:00 +0800</pubDate>
        <link>/2016/10/14/hive-add-columns.html</link>
        <guid isPermaLink="true">/2016/10/14/hive-add-columns.html</guid>
        
        
      </item>
    
      <item>
        <title>Hive中复杂count语句</title>
        <description>&lt;p&gt;最近用hive比较多，昨天需要统计数据表中满足特定条件的ip的个数，而且类似需求不止一个，最开始想的笨方法是每个需求搞个sql之后union起来，但太复杂，当时想要是能在count里的distinct基础上再加些条件就好了，之后就在网上找到了如下复杂count的示例。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;DISTINCT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;CASE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHEN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;plat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;THEN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ELSE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;END&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;DISTINCT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;CASE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHEN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;plat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;THEN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ELSE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;END&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;CASE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHEN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;OR&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;THEN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ELSE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;END&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;DISTINCT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;CASE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHEN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;OR&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;THEN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ELSE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;END&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dt&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;&amp;quot;2012-1-12-02&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&amp;quot;2012-1-12-03&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        <pubDate>Mon, 10 Oct 2016 00:00:00 +0800</pubDate>
        <link>/2016/10/10/complex-hive.html</link>
        <guid isPermaLink="true">/2016/10/10/complex-hive.html</guid>
        
        
      </item>
    
      <item>
        <title>Golang单元测试</title>
        <description>&lt;p&gt;Go语言自带了单元测试的工具 &lt;code&gt;go test&lt;/code&gt;，开发人员可以在给包添加函数的时候，顺便写个测试方法，以便后面在对该方法进行修改的时候运行下单元测试，测试下方法是否给改错了。&lt;br&gt;
如下是util包的目录结构：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;➜ /Users/zhaoxuhai/Programs/go/src &amp;gt;tree
.
└── util
    ├── compute.go
    ├── compute_test.go
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看出有两个文件：&lt;code&gt;compute.go&lt;/code&gt;里面有两个方法，&lt;code&gt;Sum&lt;/code&gt;和&lt;code&gt;Abs&lt;/code&gt;，分别用于求和和取绝对值。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;util&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//&amp;quot;fmt&amp;quot;&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Abs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要想给这两个方法添加单元测试功能，需要在同一个包下，添加xxx_test.go文件，xxx为对应要测试的文件， 
需要引用&lt;code&gt;testing&lt;/code&gt;包，同时使用&lt;code&gt;TestSum&lt;/code&gt;对Sum方法添加单元测试功能。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;util&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&amp;quot;testing&amp;quot;&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;TestSum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;testing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Fatal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;sum error&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;TestAbs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;testing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Abs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Fatal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;abs error, except:5, result:&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Abs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行方法：进入到包内，运行命令&lt;code&gt;go test -v&lt;/code&gt;，参数-v可以打印详情。&lt;br&gt;
也可以只运行某个方法的单元测试：&lt;code&gt;go test -v -run=&amp;quot;Abs&amp;quot;&lt;/code&gt;，支持正则表达式。&lt;br&gt;
运行结果:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;=== RUN   TestSum
--- PASS: TestSum (0.00s)
=== RUN   TestAbs
--- PASS: TestAbs (0.00s)
PASS
ok         util       0.006s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看出，到目前为止，这两个方法是正确的。&lt;br&gt;
&lt;code&gt;go test&lt;/code&gt;工具还有个功能是测试单元测试的覆盖率，用法为 &lt;code&gt;go test -v -cover&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;=== RUN   TestSum
--- PASS: TestSum (0.00s)
=== RUN   TestAbs
--- FAIL: TestAbs (0.00s)
compute_test.go:15: abs error, except:4, result: 5
FAIL
coverage: 85.7% of statements
exit status 1
FAIL       util       0.006s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从覆盖率来看，单元测试没有覆盖全部的代码，我们可以通过如下命令将cover的详细信息保存到cover.out中。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;go test -cover -coverprofile=cover.out -covermode=count
注：
-cover 允许代码分析
-covermode 代码分析模式（set：是否执行；count：执行次数；atomic：次数，并发执行）
-coverprofile 输出结果文件
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之后通过&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;go tool cover -func=cover.out
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看每个方法的覆盖率。&lt;br&gt;
运行结果：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;util/compute.go:7:      Sum            100.0%
util/compute.go:15:     Abs            66.7%
total:                  (statements)   85.7%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里发现是Abs方法没有覆盖完全，因为我们的用例只用到了正数的那个分支。&lt;br&gt;
还可以使用html的方式查看具体的覆盖情况。 &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;go tool cover -html=cover.out
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;会默认打开浏览器，将覆盖情况显示到页面中：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&quot;/images/cover_html.png&quot;&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;可以看出Abs方法的负数分支没有覆盖到。将TestAbs方法修改如下即可：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;TestAbs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;testing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Abs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Fatal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;abs error, except:5, result:&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Abs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Abs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Fatal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;abs error, except:4, result:&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Abs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次运行：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;go test -cover -coverprofile=cover2.out -covermode=count
go tool cover -func=cover2.out
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;util/compute.go:7:         Sum            100.0%
util/compute.go:15:        Abs            100.0%
total:             (statements)       100.0%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        <pubDate>Sun, 28 Aug 2016 00:00:00 +0800</pubDate>
        <link>/2016/08/28/go-test.html</link>
        <guid isPermaLink="true">/2016/08/28/go-test.html</guid>
        
        
      </item>
    
      <item>
        <title>hello didi</title>
        <description>&lt;p&gt;test&lt;/p&gt;
</description>
        <pubDate>Thu, 25 Aug 2016 00:00:00 +0800</pubDate>
        <link>/2016/08/25/hello-didi.html</link>
        <guid isPermaLink="true">/2016/08/25/hello-didi.html</guid>
        
        
      </item>
    
  </channel>
</rss>
